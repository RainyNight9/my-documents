<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h2>前言</h2><p>前两章，我们一起学习了物料、用户系统的设计与开发，在经过了用户系统与物料系统的折磨之后，大家应该对 <code>NestJS</code>
      已经非常的熟悉了，学习旅途也到了网关系统中<strong>最关键与核心</strong>的功能模块开发。</p><p>由于物料与网关核心功能的耦合度非常高，操作起来非常麻烦，毕竟我们没有真实的界面，所以在本章内容中，我们会使用
      <code>mock</code> 数据来实现代理转发的功能，同时对缓存数据做一个大概的介绍。</p><h2>网关核心系统开发</h2><h4>拦截路由</h4><p>在需求分析中我们提到了，网关基础服务作为所有资源的前置入口，需要对所有的请求进行拦截，再根据请求的类型分发到对应的服务或者返回需求的资源，所以我们需要一个接受所有请求的
      <code>Controller</code>。</p><p>新建 <code>src/core/intercepter.controller.ts</code>
      如下所示</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Public</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/auth/constants'</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">Controller</span>,  <span class="hljs-title class_">Get</span>,  <span class="hljs-title class_">Req</span>,  <span class="hljs-title class_">Res</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastifyReply</span>, <span class="hljs-title class_">FastifyRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'fastify'</span>;<span class="hljs-meta">@Controller</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntercepterController</span> {  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) { }  <span class="hljs-meta">@Get</span>()  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getApp</span>(<span class="hljs-params"><span class="hljs-meta">@Req</span>() req: FastifyRequest, <span class="hljs-meta">@Res</span>() res: FastifyReply</span>) {    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">'html'</span>)  }}</code></pre><blockquote><p>注意，此时的
        <code>getApp</code> 引入了 <code>@Res() res: FastifyReply</code>，不能直接
        <code>return</code> 返回值，需要使用 <code>res.send</code> 来返回 <code>html</code>
        格式</p></blockquote><p>新建 <code>src/core/intercepter.module.ts</code>，并在
      <code>app.module.ts</code> 中导入。</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">IntercepterController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./intercepter.controller'</span>;<span class="hljs-meta">@Module</span>({  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">IntercepterController</span>],})<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntercepterModule</span> { }</code></pre><p>然后请求接口
      <a href="http://localhost/api" target="_blank" rel="nofollow noopener
        noreferrer">http://localhost/api</a> （<strong>为了方便后期修改 <code>DNS</code>
        测试本地域名，可以将项目启动端口改成 80</strong>），可以得到如下返回值。</p><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f51de1f90d414269a80034eabc35089e~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>从图上看出，请求路径是携带了 <code>api</code>
      前缀的，并不符合拦截全部路由的要求，可以修改 <code>main.ts</code> 中的 <code>setGlobalPrefix</code>
      方法：</p><pre><code class="hljs language-diff"><span class="hljs-deletion">- app.setGlobalPrefix('api');</span><span class="hljs-addition">+ app.setGlobalPrefix('api', { exclude: ['*'] }); </span></code></pre><p>同时再修改
      <code>src/core/intercepter.controller.ts</code> 中的 <code>getApp</code> 的
      <code>Get</code> 配置：</p><pre><code class="hljs language-diff"><span class="hljs-deletion">- @Controller()</span><span class="hljs-addition">+ @Controller('*')</span>export class IntercepterController {  constructor() { }  @Get()  async getApp(@Req() req: FastifyRequest, @Res() res: FastifyReply) {    res.send('html')  }}</code></pre><p>然后再访问如下路由对比即可以发现，当访问到项目已存在的接口时，会正常走之前的业务逻辑，当访问不存在的业务逻辑路由时，将统一进入
      <code>IntercepterController</code> 中：</p><p><img
        src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0a80ad81024acda2f7330fad156d7f~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><h4>解析路由</h4><p>首先，我们需要根据域名来匹配不同的返回页面，在上一步已经将项目启动端口修改为
      <strong>80</strong>，所以直接修改系统的 <code>host</code> 目录，来修改域名 <code>DNS</code>
      解析，使之指向本地服务，然后浏览器访问即可：</p><pre><code class="hljs language-yaml"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">www.cookieboty.com</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">nginx.cookieboty.com</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">jenkins.cookieboty.com</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">gitlab.cookieboty.com</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">devops.cookieboty.com</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">fe.cookieboty.com</span></code></pre><pre><code class="hljs language-diff">@Controller('*')export class IntercepterController {  constructor() { }  @Get()  async getApp(@Req() req: FastifyRequest, @Res() res: FastifyReply) {<span class="hljs-deletion">-    res.send('html')</span><span class="hljs-addition">+    res.send(req.headers.host)</span>  }}</code></pre><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bba855e6a4f4205855c0d55d933bc57~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>如上图所示，我们可以通过 <code>req.headers.host</code>
      来拿到对应的域名来判断返回资源，但是仅仅有域名肯定是不足够的。</p><p>通常情况下，一个域名下面会存在多个前端项目，这些前端项目可以通过路由前缀来区分，例如
      <a href="http://www.cookieboty.com/devops" target="_blank" rel="nofollow
        noopener noreferrer">www.cookieboty.com/devops</a> 、<a
        href="http://www.cookieboty.com/jenkins" target="_blank" rel="nofollow
        noopener noreferrer">www.cookieboty.com/jenkins</a> 等等，所以我们也需要对整个 <code>url</code>
      进行解析。</p><p>同时，也存在 <code>SPA</code> 项目中使用 <code>history</code>
      的情况，这样的话就会存在虚拟路由，真实的访问地址与浏览器请求的地址不匹配的情况，我们也需要模拟 <code>Nginx</code> 中的
      <code>try_files</code> 模式。</p><p><code>第一步</code>：借助 <code>url</code>
      库来组装路由</p><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { URL } from 'url';</span>export class IntercepterController {  constructor() { }  @Get()  async getApp(@Req() req: FastifyRequest, @Res() res: FastifyReply) {<span class="hljs-addition">+   const urlObj = new URL(req.url, `http://${req.headers.host}`);</span><span class="hljs-addition">+   console.log('urlObj===>', urlObj)</span>    res.send(req.headers.host)  }}</code></pre><p>访问之前的域名可以在控制台得到如下的结构：</p><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7457f9da2d4868982713167018d3c6~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><blockquote><p>可以看到控制台中有两种打印，普通的 <code>html</code>
        会自动请求 <code>favicon</code> 资源，我们只需要拦截正常的请求，过滤掉 <code>favicon.ico</code>
        这种类型的请求即可，或者返回一个通用的小图标也行。</p></blockquote><p><strong>第二步</strong>：修改
      <code>IntercepterController</code>，添加读取 <code>html</code> 方法与判断空异常：</p><pre><code>@Controller()export class IntercepterController {  constructor(private readonly intercepterService: IntercepterService) { }  @Get('*')  @Public()  async getApp(@Req() req: FastifyRequest, @Res() res: FastifyReply) {    const urlObj = new URL(req.url, `http://${req.headers.host}`);        if (urlObj.pathname === '/favicon.ico') return res.send('ico');        const html = await this.intercepterService.readHtml(urlObj);   if (!html) return res.send('404');       res.headers({      'Content-Type': 'text/html',    });    res.send(html);  }}</code></pre><p><strong>第三步</strong>：新建
      <code>src/core/intercepter.service.ts</code> 添加 <code>IntercepterService</code></p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">WebSiteDataModel</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./types'</span>;<span class="hljs-keyword">import</span> { getMatchedSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'./intercepter'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ConfigService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/config'</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">WebsitesMock</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./websites_mock.json'</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">FilesMock</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./files_mock.json'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntercepterService</span> {  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) { }  <span class="hljs-keyword">get</span> <span class="hljs-title function_">websites</span>(): <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">WebSiteDataModel</span>> {    <span class="hljs-keyword">return</span> <span class="hljs-title class_">WebsitesMock</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">WebSiteDataModel</span>>  }  <span class="hljs-keyword">async</span> <span class="hljs-title function_">readHtml</span>(<span class="hljs-params">urlObj: URL</span>) {    <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: matchedData } = <span class="hljs-title function_">getMatchedSync</span>(urlObj, <span class="hljs-variable language_">this</span>.<span class="hljs-property">websites</span>);    <span class="hljs-keyword">if</span> (!matchedData) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">const</span> html = <span class="hljs-title class_">FilesMock</span>[matchedData.<span class="hljs-property">pageId</span>]    <span class="hljs-keyword">return</span> html;  }}</code></pre><p><code>files_mock.json</code></p><pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>  <span class="hljs-attr">"1"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"devops"</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">"2"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"jenkins"</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">"3"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"nginx"</span><span class="hljs-punctuation">}</span></code></pre><p><code>websites_mock.json</code></p><pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>  <span class="hljs-attr">"www.cookieboty.com"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>    <span class="hljs-attr">"/devops"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>      <span class="hljs-attr">"lastModified"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>      <span class="hljs-attr">"pageId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">"/jenkins"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>      <span class="hljs-attr">"lastModified"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>      <span class="hljs-attr">"pageId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span>    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">"/nginx"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>      <span class="hljs-attr">"lastModified"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>      <span class="hljs-attr">"pageId"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span>    <span class="hljs-punctuation">}</span>  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span></code></pre><p><strong>第四步</strong>：创建解析
      <code>url</code> 的方法，解析路由地址，例如将 <code>devops/list</code>、<code>devops/detail</code>
      等路由全部指向到根路由地址 <code>devops</code> 的资源上，在第三步中的 <code>getMatchedSync</code>
      方法就用作此判断：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getMatchedSync = (  <span class="hljs-attr">urlObj</span>: <span class="hljs-variable constant_">URL</span>,  <span class="hljs-attr">websites</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">WebSiteDataModel</span>> = {},): { <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>; <span class="hljs-attr">data</span>: <span class="hljs-title class_">PageModelItem</span> | <span class="hljs-literal">undefined</span> } | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span> {  <span class="hljs-keyword">if</span> (!urlObj.<span class="hljs-property">hostname</span>) {    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  }  <span class="hljs-keyword">const</span> website = <span class="hljs-title function_">matchWebsite</span>(urlObj.<span class="hljs-property">hostname</span>, websites);  <span class="hljs-keyword">if</span> (!website) {    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  }  <span class="hljs-keyword">const</span> { data, path } = <span class="hljs-title function_">matchPath</span>(website, urlObj.<span class="hljs-property">pathname</span>);  <span class="hljs-keyword">if</span> (!data) {    <span class="hljs-keyword">return</span> { <span class="hljs-attr">path</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">data</span>: <span class="hljs-literal">undefined</span> };  }  <span class="hljs-keyword">return</span> { data, path };}</code></pre><p>先由
      <code>matchWebsite</code> 来匹配 <code>host</code>，获取匹配成功的 <code>host</code>
      数据之后，再使用 matchPath 方法进行 <code>path</code> 的匹配：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> matchWebsite = (  <span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>,  <span class="hljs-attr">websites</span>: <span class="hljs-title class_">Record</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">WebSiteDataModel</span>>,): <span class="hljs-title class_">WebSiteDataModel</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span> {  <span class="hljs-keyword">return</span> websites[host];}<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> matchPath = (  <span class="hljs-attr">website</span>: <span class="hljs-title class_">WebSiteDataModel</span> | <span class="hljs-literal">undefined</span>,  <span class="hljs-attr">targetPath</span>: <span class="hljs-built_in">string</span>,): { <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">data</span>: <span class="hljs-title class_">PageModelItem</span> } | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span> {  <span class="hljs-keyword">if</span> (!website) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">const</span> targetPathArr = <span class="hljs-title function_">splitPath</span>(targetPath);  <span class="hljs-keyword">if</span> (targetPathArr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> i === <span class="hljs-string">'*'</span>)) {    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(      <span class="hljs-string">'[matchPath] website custome path include *, redirect to 404'</span>,    );  }  <span class="hljs-comment">// 全匹配</span>  <span class="hljs-keyword">if</span> (website[targetPath]) {    <span class="hljs-keyword">return</span> {      <span class="hljs-attr">path</span>: targetPath,      <span class="hljs-attr">data</span>: website[targetPath],    };  }  <span class="hljs-comment">// .html 后缀 且 不等于 index.html,</span>  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">//[^/]+.html$/</span>.<span class="hljs-title function_">test</span>(targetPath) &#x26;&#x26; !<span class="hljs-regexp">//index.html/</span>.<span class="hljs-title function_">test</span>(targetPath)) {    <span class="hljs-keyword">return</span> {      <span class="hljs-attr">path</span>: targetPath,      <span class="hljs-attr">data</span>: website[targetPath],    };  }  <span class="hljs-comment">// 通配</span>  <span class="hljs-keyword">let</span> matchLen = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> <span class="hljs-attr">resultKey</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(website.<span class="hljs-property">path</span> || {}).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">path</span>) =></span> {    <span class="hljs-keyword">if</span> (!path.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'/'</span>)) path = <span class="hljs-string">`/<span class="hljs-subst">${path}</span>`</span>;    <span class="hljs-keyword">const</span> pathArr = <span class="hljs-title function_">splitPath</span>(path);    <span class="hljs-comment">// 非必须容错：仅允许最后一个字符出现 *</span>    <span class="hljs-keyword">if</span> (pathArr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">i</span>) =></span> i === <span class="hljs-string">'*'</span>))      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'[matchPath] path include *'</span>);    <span class="hljs-comment">/**     * 遍历路由规则列表，匹配命中立即停止遍历     */</span>    <span class="hljs-keyword">let</span> currentMatchLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> <span class="hljs-attr">currentResultKey</span>: <span class="hljs-built_in">string</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; pathArr.<span class="hljs-property">length</span>; i += <span class="hljs-number">1</span>) {      <span class="hljs-keyword">if</span> (targetPathArr[i] !== pathArr[i]) {        currentMatchLen = <span class="hljs-number">0</span>;        currentResultKey = <span class="hljs-literal">undefined</span>;        <span class="hljs-keyword">return</span>;      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">undefined</span> === targetPathArr[i]) {        currentMatchLen = <span class="hljs-number">0</span>;        currentResultKey = <span class="hljs-literal">undefined</span>;        <span class="hljs-keyword">return</span>;      }      currentMatchLen = i + <span class="hljs-number">1</span>;      currentResultKey = path;    }    <span class="hljs-keyword">if</span> (matchLen &#x3C; currentMatchLen) {      matchLen = currentMatchLen;      resultKey = currentResultKey;    }  });  <span class="hljs-keyword">return</span> {    <span class="hljs-attr">path</span>: resultKey,    <span class="hljs-attr">data</span>: website.<span class="hljs-property">path</span>[resultKey],  };}</code></pre><h4>获取资源</h4><p>在解析路由的第三步中，大家应该注意到在路由匹配中，有
      <strong>2</strong> 个 <code>mock json</code> 文件 <code>websites_mock.json</code>
      与 <code>files_mock.json</code>，它是由物料系统中的 <code>pages</code> 组成的，具体的结构为：</p><pre><code class="hljs language-ts"><span class="hljs-comment">/** * <span class="hljs-doctag">@description</span> 站点数据模型 */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WebSiteDataModel</span> {  <span class="hljs-comment">/**   * <span class="hljs-doctag">@description</span> 站点下的所有 path 表   */</span>  [<span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span>]: {    [<span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">PageModelItem</span>;  }}<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageModelItem</span> {  <span class="hljs-comment">/**   * <span class="hljs-doctag">@description</span> 最后修改时间   */</span>  lastModified?: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">/**   * <span class="hljs-doctag">@description</span> 页面 id   */</span>  pageId?: <span class="hljs-built_in">number</span>;    <span class="hljs-comment">/**   * <span class="hljs-doctag">@description</span> 权限   */</span>  permissions?: <span class="hljs-title class_">Array</span>&#x3C;<span class="hljs-function">() =></span> (<span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-built_in">boolean</span>>) | <span class="hljs-built_in">boolean</span>>;}</code></pre><p>正常情况下，我们是需要通过
      <code>pageId</code> 去数据库查询出对应的资源返回，不过在 <code>mock</code>
      的情况省略了，现在我们一起来看看结果如何：</p><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97b6feac96e49ecaf6f4ef51828c0c5~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><blockquote><p>注意 <a
          href="http://www.cookieboty.com/jenkins/list" target="_blank"
          rel="nofollow noopener noreferrer">http://www.cookieboty.com/jenkins/list</a>
        与 <a href="http://www.cookieboty.com/jenkins" target="_blank"
          rel="nofollow noopener noreferrer">http://www.cookieboty.com/jenkins</a>
        这两个路由，它就是之前所提到过的虚拟路由匹配，当访问的资源为 <code>SPA</code> 项目使用 <code>history</code>
        构建的话，<code>jenkins</code> 之后所有的路径都需要强制指向 <code>jenkins</code> 这个路由上。</p></blockquote><h4>缓存</h4><p>由于我们是静态资源代理，所以为了达到最快的访问速度，给用户提供最高的性能体验，可以借助
      <strong>3</strong> 层缓存来实现。</p><p><strong>第一层缓存</strong>：由客户端自身在访问之后产生的协商缓存，当请求资源不变的情况下，用户访问的是本地资源，这个知识点，大部分的前端同学都应该掌握的非常熟悉，这里就不再拓展了。接下来介绍一下，在我们的项目中如何利用缓存来提高访问效率。</p><p><img
        src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c75a9135fbb4e10b1eeb3cbb14e0f62~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>如上图所示，第二层缓存与第三层缓存分别是程序运行本地服务器与 <strong>Redis</strong>
      服务。</p><p>当第一个用户在访问页面时，如果在本地没有查询到资源的话，会向 <strong>Redis</strong> 服务请求资源，当
      <strong>Redis</strong> 服务也没有请求到对应的资源的话，最后再去请求 <strong>MongoDB</strong> 获取。</p><p>同样在每一次请求到资源的情况下，都会在对应的层级缓存资源，这样任一一个用户访问资源之后，就会产生缓存数据，这样可以减少数据库的读写，同时提高响应速度。</p><p>可能有同学说
      <code>Redis</code>
      这一层可以省略，但一般网关服务也会使用分布式部署方式，在分布式架构中你命中的服务不一定是在本地有缓存了，所以即使丢失本地缓存，也不能舍弃
      <code>Redis</code>，当任一的服务命中资源之后，都会在 <code>Redis</code>
      中产生缓存，其他的服务也可以共享缓存数据。</p><p>另外在本地缓存中，由于会存储大量的文件，所以也会存在旧版资源冗余的情况，所以在之前的设计中，永远都只保存最新的资源产物，不会保留历史产物，通过
      <code>lastModified</code> 参数来判断需要更新资源。</p><p>当资源过多的情况下也可以使用 <code>LRU</code>
      算法来清空本地资源，看需求进行功能拓展即可，大家尽情发挥，不用客气。</p><blockquote><p>在缓存的工具选择上，大家可以选择自己熟悉的工具即可，只是
        <code>NestJS</code> 自带的缓存插件对接 <code>Redis</code> 比较方便，并不代表你一定要使用 <code>Redis</code>
        才行，比如我们公司目前的缓存使用的是 <code>Nacos</code>。</p></blockquote><h2>写在最后</h2><p>本章的代码地址为
      <a href="https://github.com/boty-design/gateway/tree/feat/core"
        target="_blank" rel="nofollow noopener noreferrer">feat/core</a>，需要的同学自取，会持续更新。</p><p>由于篇幅所限，文章里面提到的开发内容比较少，只有最核心的两个功能，其他的功能可以等待完整的项目出来之后再对比学习即可，一般关键的地方我会做必要的注释，如果还有其他的问题可以加群讨论或者直接联系我都行。</p><p>到目前为止，我们已经陆陆续续开发
      <strong>3</strong> 个大的功能模块，大家应该能感觉到目前的工程已经很庞大了，如果是普通开发模式的话，每一次的重启速度已经变慢。</p><p>整个项目目前已经有
      <strong>40+</strong> 个接口，如果物料系统再复杂点的话，已经 <strong>50+</strong> 的接口不在话下。而这只是
      <code>Controller</code> 的数量，并未括工具类与 <code>Service</code> 层的代码。</p><p>所以在接下来下一章，我们将对这个逐渐变成巨石的工程进行项目拆分，降低项目之间的耦合度，做到独立部署与独立开发。</p><p>如果你有什么疑问，欢迎在评论区提出或者加群沟通。
      👏</p>
  </body>
</html>