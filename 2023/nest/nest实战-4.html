<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h2>前言</h2><p>在上一章节中，我们学习了 <code>NestJS CLI</code>
      的用法，得到了一套基础的项目工程。最开始做项目对比的时候也提到过，<code>NestJS</code> 作为一款<strong>自定义程度较高</strong>的框架，<code>CLI</code>
      直接提供的基础功能虽然并不完善，但同时也为开发者提供了非常多的内置或配套的功能例如<strong>高速缓存、日志拦截、过滤器、微服务</strong>等多种模块，方便开发者根据自身的业务需求定制适合当前业务的工程。</p><p>本章将根据业务需求或者团队规范，选择对应的模块搭建出一个符合要求的通用性脚手架。</p><h2>Fastify</h2><p>对于网关系统来说，无论是资源还是
      <code>API</code> 接口数据，它都将承担所有的请求转发，虽然外层可以有 <code>Nginx</code>
      做负载均衡策略，但如果框架本身的性能越好，业务实现的效果就会越好，同时对业务代码要求也可以稍微降低一点。</p><blockquote><p>框架或者语言带来的性能提升还是非常重要的。可以给大家举一个明显的例子，<strong>Windows</strong>
        自带的 <code>VBS</code> 脚本可以操作 <strong>Excel</strong>，<code>Java</code>
        或者其他语言框架也可以操作 <strong>Excel</strong>。但是，其他语言的操作效率会远超 <code>VBS</code>，即使是在操作更为复杂或者文件读写内容更多的情况下。这里我们并不去深究为什么其他语言的速度会更快，但是对于一个快速迭代的业务项目或者小团队来说，选择效率高、性能高的框架作为开发语言无疑是降低整体成本最好的一种方式。</p></blockquote><p>而
      <code>Nest</code> 作为一个上层框架，可以通过适配器模式使得底层可以兼容任意 <code>HTTP</code> 类型的
      <code>Node</code> 框架，本身内置的框架有两种 <a href="https://expressjs.com/"
        target="_blank" rel="nofollow noopener noreferrer">Express</a> 与 <a
        href="https://www.fastify.io/" target="_blank" rel="nofollow noopener
        noreferrer">Fastify</a>。</p><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3aaf3b9e3b64b6ca5bd0afb3d7b1d4b~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>如上图所示，<code>Fastify</code> 与其他主流 <code>HTTP</code>
      框架对比，其在 <strong>QPS</strong>(<strong>并发处理请求</strong>)的效率上要远超其他框架，达到了几乎两倍的基准测试结果，所以在网关系统这个对性能要求非常高的项目中使用
      <code>Fastify</code> 无疑是一种非常好的选择。</p><blockquote><p>当然具体的性能开销、优化大部分还是依赖业务复杂度以及代码质量，框架能够提供的是只是一层基础架构。能从这层架构上搭建出什么样的产品，取决于开发者自身。同时，我并不是鼓励所有的项目都使用
        <code>Fastify</code>，在业务复杂度以及对性能要求并非十分敏感的项目中，<code>Express</code>
        也是一种非常好的选择。作为老牌的框架，它经历了非常多的大型项目实战的考验以及长期的迭代，所以 <code>Express</code>
        社区生态非常的丰富，遇到任何的问题都可以快速找到解决方案，这也是 <code>NestJS</code> 采用 <code>Express</code>
        作为默认基础框架的原因。</p></blockquote><p>介绍完 <code>Fastify</code>
      的优势之后，接下来我们开始着手改造模板项目框架。首先，通过 <code>CLI</code> 默认生成的项目框架中，底层平台使用的是 <code>Express</code>，代码如下所示：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);}<span class="hljs-title function_">bootstrap</span>();</code></pre><p>毕竟
      <code>Fastify</code> 作为唯二内置的平台，整体的替换过程会非常顺畅。首先，安装对应的适配器依赖 <code>@nestjs/platform-fastify</code>。其次，使用
      <code>FastifyAdapter</code> 替换默认的 <code>Express</code> 。</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">FastifyAdapter</span>,  <span class="hljs-title class_">NestFastifyApplication</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/platform-fastify'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-property">create</span>&#x3C;<span class="hljs-title class_">NestFastifyApplication</span>>(    <span class="hljs-title class_">AppModule</span>,    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastifyAdapter</span>(),  );  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);}<span class="hljs-title function_">bootstrap</span>();</code></pre><h2>版本控制</h2><p>之前学习过
      <strong>DevOps</strong> 小册的同学，应该对 <a
        href="https://docs.gitlab.com/ee/api/" target="_blank" rel="nofollow
        noopener noreferrer">GitLab OpenApi</a> 比较熟悉，肯定也使用过这样的请求 <strong><a
          href="https://gitlab.example.com/api/v4/projects" target="_blank"
          rel="nofollow noopener noreferrer">https://gitlab.example.com/api/v4/projects</a></strong>
      ，可以看出链接上面是带 v4 版本的。</p><p>因为我们有两种项目分别是<strong>物料</strong>与<strong>用户</strong>，这两款系统作为基础应用，后期也会对其他的项目提供类似的
      Open Api，同时避免不了升级之后，需要兼容老项目的情况。此时就会存在多种版本的
      Api，所以我们也在工程添加版本控制来避免未来升级的时候，造成其他系统崩溃。</p><h4>单个请求控制</h4><p><strong>第一步</strong>：在
      <code>main.ts</code> 启用版本配置：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">VersioningType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">FastifyAdapter</span>,  <span class="hljs-title class_">NestFastifyApplication</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/platform-fastify'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.module'</span>;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-property">create</span>&#x3C;<span class="hljs-title class_">NestFastifyApplication</span>>(    <span class="hljs-title class_">AppModule</span>,    <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastifyAdapter</span>(),  );  <span class="hljs-comment">// 接口版本化管理</span>  app.<span class="hljs-title function_">enableVersioning</span>({    <span class="hljs-attr">type</span>: <span class="hljs-title class_">VersioningType</span>.<span class="hljs-property">URI</span>,  });  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);}<span class="hljs-title function_">bootstrap</span>();</code></pre><p><strong>第二步</strong>：启用版本配置之后再在
      <code>Controller</code> 中请求方法添加对应的版本号装饰器：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Version</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;  <span class="hljs-meta">@Get</span>()  <span class="hljs-meta">@Version</span>(<span class="hljs-string">'1'</span>)  <span class="hljs-title function_">findAll</span>(<span class="hljs-params"></span>) {    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findAll</span>();  }</code></pre><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2015a74a73e04d32a9672c9a46e508c8~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>配置完毕之后从上图可以看到，只有携带了版本号的请求 <a
        href="http://localhost:3000/v1/user" target="_blank" rel="nofollow
        noopener noreferrer">http://localhost:3000/v1/user</a>
      能正常返回数据，而之前未携带版本号的请求 <a href="http://localhost:3000/user" target="_blank"
        rel="nofollow noopener noreferrer">http://localhost:3000/user</a> 返回了
      404 错误。</p><p>除了针对某一个请求添加版本之外，同样也可以添加全局以及整个 <code>Controller</code>
      的版本，具体的版本配置规则可以根据自己的实际需求取舍。</p><h4>全局配置请求控制</h4><p><strong>第一步</strong>：修改
      <code>enableVersioning</code> 配置项：</p><pre><code class="hljs language-diff">app.enableVersioning({<span class="hljs-addition">+   defaultVersion: '1',</span>    type: VersioningType.URI,});</code></pre><p><strong>第二步</strong>：修改
      <code>Controller</code> 的配置，在 <code>Controller</code> 装饰器中添加 <code>version</code>
      属性：</p><pre><code class="hljs language-diff"><span class="hljs-deletion">- @Get()</span><span class="hljs-deletion">- @Version('1')</span><span class="hljs-addition">+ @Controller({</span><span class="hljs-addition">+  path: 'user',</span><span class="hljs-addition">+  version: '1',</span><span class="hljs-addition">+ })</span></code></pre><p>完成上述的操作就可以对一整个
      <code>Controller</code>
      进行版本控制。但有的时候，我们需要做针对一些接口做兼容性的更新，而其他的请求是不需要携带版本，又或者请求有多个版本的时候，而默认请求想指定一个版本的话，我们可以在
      <code>enableVersioning</code> 添加 <code>defaultVersion</code> 参数达到上述的要求：</p><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { VersioningType, VERSION_NEUTRAL } from '@nestjs/common';</span>  app.enableVersioning({<span class="hljs-deletion">-    defaultVersion: '1',</span><span class="hljs-addition">+    defaultVersion: [VERSION_NEUTRAL, '1', '2']</span>  });</code></pre><pre><code class="hljs language-ts">  <span class="hljs-meta">@Get</span>()  <span class="hljs-meta">@Version</span>([<span class="hljs-variable constant_">VERSION_NEUTRAL</span>, <span class="hljs-string">'1'</span>])  <span class="hljs-title function_">findAll</span>(<span class="hljs-params"></span>) {    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findAll</span>();  }  <span class="hljs-meta">@Get</span>()  <span class="hljs-meta">@Version</span>(<span class="hljs-string">'2'</span>)  <span class="hljs-title function_">findAll2</span>(<span class="hljs-params"></span>) {    <span class="hljs-keyword">return</span> <span class="hljs-string">'i am new one'</span>;  }</code></pre><p>接下来分别访问对应的请求<a
        href="http://localhost:3000/user" target="_blank" rel="nofollow noopener
        noreferrer">http://localhost:3000/user</a> 与 <a
        href="http://localhost:3000/v2/user" target="_blank" rel="nofollow
        noopener noreferrer">http://localhost:3000/v2/user</a> 可以获取到如下的返回值：</p><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38d458d6dedc49a7949b5cd0d84def5b~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><h2>全局返回参数</h2><p>在配置版本的过程中，也不断地测试了很多次接口，不难发现返回的接口数据非常的不标准，在一个正常的项目中不太合适用这种数据结构返回，毕竟这样对前端不友好，也不利于前端做统一的拦截与取值，所以需要格式化请求参数，输出统一的接口规范。</p><p>一般正常项目的返回参数应该包括如下的内容：</p><pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>    data<span class="hljs-punctuation">,</span> <span class="hljs-comment">// 数据</span>    status<span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 接口状态值</span>    extra<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 拓展信息</span>    message<span class="hljs-punctuation">:</span> 'success'<span class="hljs-punctuation">,</span> <span class="hljs-comment">// 异常信息</span>    success：<span class="hljs-keyword">true</span> <span class="hljs-comment">// 接口业务返回状态</span><span class="hljs-punctuation">}</span></code></pre><p>想要输出上述标准的返回参数格式的话：</p><p><strong>第一步</strong>：新建
      <code>src/common/interceptors/transform.interceptor.ts</code> 文件：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> {  <span class="hljs-title class_">Injectable</span>,  <span class="hljs-title class_">NestInterceptor</span>,  <span class="hljs-title class_">ExecutionContext</span>,  <span class="hljs-title class_">CallHandler</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Response</span>&#x3C;T> {  <span class="hljs-attr">data</span>: T;}<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformInterceptor</span>&#x3C;T>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NestInterceptor</span>&#x3C;T, <span class="hljs-title class_">Response</span>&#x3C;T>>{  <span class="hljs-title function_">intercept</span>(    <span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>,    <span class="hljs-attr">next</span>: <span class="hljs-title class_">CallHandler</span>,  ): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">Response</span>&#x3C;T>> {    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>().<span class="hljs-title function_">pipe</span>(      <span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> ({        data,        <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">extra</span>: {},        <span class="hljs-attr">message</span>: <span class="hljs-string">'success'</span>,        <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,      })),    );  }}</code></pre><p><strong>第二步</strong>：修改
      <code>main.ts</code> 文件，添加 <code>useGlobalInterceptors</code> 全局拦截器，处理返回值</p><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { TransformInterceptor } from './common/interceptors/transform.interceptor';</span>// 统一响应体格式<span class="hljs-addition">+ app.useGlobalInterceptors(new TransformInterceptor());</span></code></pre><p>然后我们再次访问之前的请求，就能获取到标准格式的接口返回值了：</p><p><img
        src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/826099eac0d4471b922d919d64e6040e~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><h2>全局异常拦截</h2><p>处理完正常的返回参数格式之后，对于异常处理也应该做一层标准的封装，这样利于开发前端的同学统一处理这类异常错误。</p><p><strong>第一步</strong>：新建
      <code>src/common/exceptions/base.exception.filter.ts</code> 与 <code>http.exception.filter.ts</code>
      两个文件，从命名中可以看出它们分别处理<strong>统一异常</strong>与 <code>HTTP</code> 类型的接口相关异常。</p><p><code>base.exception.filter</code>
      => <strong><code>Catch</code> 的参数为空时，默认捕获所有异常</strong></p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastifyReply</span>, <span class="hljs-title class_">FastifyRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"fastify"</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">ExceptionFilter</span>,  <span class="hljs-title class_">Catch</span>,  <span class="hljs-title class_">ArgumentsHost</span>,  <span class="hljs-title class_">HttpStatus</span>,  <span class="hljs-title class_">ServiceUnavailableException</span>,  <span class="hljs-title class_">HttpException</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-meta">@Catch</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllExceptionsFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: <span class="hljs-title class_">Error</span>, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {    <span class="hljs-keyword">const</span> ctx = host.<span class="hljs-title function_">switchToHttp</span>();    <span class="hljs-keyword">const</span> response = ctx.<span class="hljs-property">getResponse</span>&#x3C;<span class="hljs-title class_">FastifyReply</span>>();    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&#x3C;<span class="hljs-title class_">FastifyRequest</span>>();    request.<span class="hljs-property">log</span>.<span class="hljs-title function_">error</span>(exception)    <span class="hljs-comment">// 非 HTTP 标准异常的处理。</span>    response.<span class="hljs-title function_">status</span>(<span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">SERVICE_UNAVAILABLE</span>).<span class="hljs-title function_">send</span>({      <span class="hljs-attr">statusCode</span>: <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">SERVICE_UNAVAILABLE</span>,      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),      <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,      <span class="hljs-attr">message</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceUnavailableException</span>().<span class="hljs-title function_">getResponse</span>(),    });  }}</code></pre><p><code>http.exception.filter.ts</code>
      => <code>Catch</code> 的参数为 <code>HttpException</code> 将只捕获 <code>HTTP</code>
      相关的异常错误</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastifyReply</span>, <span class="hljs-title class_">FastifyRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"fastify"</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">ExceptionFilter</span>,  <span class="hljs-title class_">Catch</span>,  <span class="hljs-title class_">ArgumentsHost</span>,  <span class="hljs-title class_">HttpException</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-meta">@Catch</span>(<span class="hljs-title class_">HttpException</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpExceptionFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: <span class="hljs-title class_">HttpException</span>, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {    <span class="hljs-keyword">const</span> ctx = host.<span class="hljs-title function_">switchToHttp</span>();    <span class="hljs-keyword">const</span> response = ctx.<span class="hljs-property">getResponse</span>&#x3C;<span class="hljs-title class_">FastifyReply</span>>();    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&#x3C;<span class="hljs-title class_">FastifyRequest</span>>();    <span class="hljs-keyword">const</span> status = exception.<span class="hljs-title function_">getStatus</span>();    response.<span class="hljs-title function_">status</span>(status).<span class="hljs-title function_">send</span>({      <span class="hljs-attr">statusCode</span>: status,      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),      <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,      <span class="hljs-attr">message</span>: exception.<span class="hljs-title function_">getResponse</span>(),    });  }}</code></pre><p><strong>第二步</strong>：在
      <code>main.ts</code> 文件中添加 <code>useGlobalFilters</code> 全局过滤器：</p><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { AllExceptionsFilter } from './common/exceptions/base.exception.filter';</span><span class="hljs-addition">+ import { HttpExceptionFilter } from './common/exceptions/http.exception.filter';</span>  // 异常过滤器<span class="hljs-addition">+ app.useGlobalFilters(new AllExceptionsFilter(), new HttpExceptionFilter());</span></code></pre><blockquote><p><strong>这里一定要注意引入自定义异常的先后顺序，不然异常捕获逻辑会出现混乱</strong>。</p></blockquote><p>完成上述操作之后开始检验是否配置正常。首先访问一个不存在的接口
      <a href="http://localhost:3000/test" target="_blank" rel="nofollow
        noopener noreferrer">http://localhost:3000/test</a>
      ，此时可以对比自定义与原生的异常返回参数区别。</p><p><img
        src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0b8f5e7f9b24dcaacf33ab10d88f613~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>验证完 <code>HTTP</code> 异常之后，我们接着在 <code>UserController</code>
      中伪造一个程序运行异常的接口，来验证常规异常是否能被正常捕获：</p><pre><code class="hljs language-less">  <span class="hljs-variable">@Get</span>(<span class="hljs-string">'findError'</span>)  <span class="hljs-variable">@Version</span>([VERSION_NEUTRAL, <span class="hljs-string">'1'</span>])  findError() {    <span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">a</span>: <span class="hljs-selector-tag">any</span> = {}    console.log(a.b.c)    return this.userService.findAll();  }</code></pre><p>再次访问
      <a href="http://localhost:3000/user/findError" target="_blank"
        rel="nofollow noopener noreferrer">http://localhost:3000/user/findError</a>
      ，此时可以看到原生与自定义返回的异常错误存在一定的区别了。</p><p><img
        src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23892fd1a32e4e4cba805df4e3bf7892~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>除了全局异常拦截处理之外，我们需要再新建一个 <code>business.exception.ts</code>
      来处理业务运行中预知且主动抛出的异常：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HttpException</span>, <span class="hljs-title class_">HttpStatus</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">BUSINESS_ERROR_CODE</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./business.error.codes'</span>;<span class="hljs-keyword">type</span> <span class="hljs-title class_">BusinessError</span> = {  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span>;  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;};<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HttpException</span> {  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">err: BusinessError | <span class="hljs-built_in">string</span></span>) {    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> err === <span class="hljs-string">'string'</span>) {      err = {        <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">BUSINESS_ERROR_CODE</span>.<span class="hljs-property">COMMON</span>,        <span class="hljs-attr">message</span>: err,      };    }    <span class="hljs-variable language_">super</span>(err, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">OK</span>);  }  <span class="hljs-keyword">static</span> <span class="hljs-title function_">throwForbidden</span>(<span class="hljs-params"></span>) {    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>({      <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">BUSINESS_ERROR_CODE</span>.<span class="hljs-property">ACCESS_FORBIDDEN</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">'抱歉哦，您无此权限！'</span>,    });  }}</code></pre><pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BUSINESS_ERROR_CODE</span> = {  <span class="hljs-comment">// 公共错误码</span>  <span class="hljs-attr">COMMON</span>: <span class="hljs-number">10001</span>,  <span class="hljs-comment">// 特殊错误码</span>  <span class="hljs-attr">TOKEN_INVALID</span>: <span class="hljs-number">10002</span>,  <span class="hljs-comment">// 禁止访问</span>  <span class="hljs-attr">ACCESS_FORBIDDEN</span>: <span class="hljs-number">10003</span>,  <span class="hljs-comment">// 权限已禁用</span>  <span class="hljs-attr">PERMISSION_DISABLED</span>: <span class="hljs-number">10003</span>,  <span class="hljs-comment">// 用户已冻结</span>  <span class="hljs-attr">USER_DISABLED</span>: <span class="hljs-number">10004</span>,};</code></pre><p>简单改造一下
      <code>HttpExceptionFilter</code>，在处理 <code>HTTP</code> 异常返回之前先处理业务异常：</p><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FastifyReply</span>, <span class="hljs-title class_">FastifyRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"fastify"</span>;<span class="hljs-keyword">import</span> {  <span class="hljs-title class_">ExceptionFilter</span>,  <span class="hljs-title class_">Catch</span>,  <span class="hljs-title class_">ArgumentsHost</span>,  <span class="hljs-title class_">HttpException</span>,  <span class="hljs-title class_">HttpStatus</span>,} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessException</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./business.exception"</span>;<span class="hljs-meta">@Catch</span>(<span class="hljs-title class_">HttpException</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpExceptionFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExceptionFilter</span> {  <span class="hljs-keyword">catch</span>(<span class="hljs-attr">exception</span>: <span class="hljs-title class_">HttpException</span>, <span class="hljs-attr">host</span>: <span class="hljs-title class_">ArgumentsHost</span>) {    <span class="hljs-keyword">const</span> ctx = host.<span class="hljs-title function_">switchToHttp</span>();    <span class="hljs-keyword">const</span> response = ctx.<span class="hljs-property">getResponse</span>&#x3C;<span class="hljs-title class_">FastifyReply</span>>();    <span class="hljs-keyword">const</span> request = ctx.<span class="hljs-property">getRequest</span>&#x3C;<span class="hljs-title class_">FastifyRequest</span>>();    <span class="hljs-keyword">const</span> status = exception.<span class="hljs-title function_">getStatus</span>();    <span class="hljs-comment">// 处理业务异常</span>    <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">BusinessException</span>) {      <span class="hljs-keyword">const</span> error = exception.<span class="hljs-title function_">getResponse</span>();      response.<span class="hljs-title function_">status</span>(<span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">OK</span>).<span class="hljs-title function_">send</span>({        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">status</span>: error[<span class="hljs-string">'code'</span>],        <span class="hljs-attr">extra</span>: {},        <span class="hljs-attr">message</span>: error[<span class="hljs-string">'message'</span>],        <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>,      });      <span class="hljs-keyword">return</span>;    }    response.<span class="hljs-title function_">status</span>(status).<span class="hljs-title function_">send</span>({      <span class="hljs-attr">statusCode</span>: status,      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>(),      <span class="hljs-attr">path</span>: request.<span class="hljs-property">url</span>,      <span class="hljs-attr">message</span>: exception.<span class="hljs-title function_">getResponse</span>(),    });  }}</code></pre><blockquote><p>由于异常拦截的返回函数使用的是
        <code>Fastify</code> 提供的，所以我们使用的返回方法是 <code>.send（）</code>，如果你没有使用
        <code>Fastify</code> 作为 <code>HTTP</code> 底层服务的话，拦截返回的方法要保持跟官网一致（官网默认的是
        <code>Express</code> 的框架，所以返回方法不一样）。</p></blockquote><p>完成配置之后，我们继续在
      <code>UserController</code> 中重新伪造一个业务异常的场景：</p><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { BusinessException } from 'src/common/exceptions/business.exception';</span>  @Get('findBusinessError')  @Version([VERSION_NEUTRAL, '1'])  findBusinessError() {    const a: any = {}    try {      console.log(a.b.c)    } catch (error) {      throw new BusinessException('你这个参数错了')    }    return this.userService.findAll();  }</code></pre><p>访问接口
      <a href="http://localhost:3000/user/findBusinessError" target="_blank"
        rel="nofollow noopener noreferrer">http://localhost:3000/user/findBusinessError</a>
      ，可以看到能够返回我们预期的错误了。</p><p><img
        src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e2d881639342428a05875258e7dba3~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><blockquote><p>自定义业务异常的优点在于，当你的业务逻辑复杂到一定的地步，在任意的一处出现可预知的错误，此时可以直接抛出异常让用户感知，不需要写很多冗余的返回代码。</p></blockquote><p>异常拦截、全局返回参数修改以及替换
      <code>Fastify</code> 框架的代码已上传 <a
        href="https://github.com/boty-design/gateway/tree/demo/v2"
        target="_blank" rel="nofollow noopener noreferrer">demo/v2</a>，
      需要的同学可以自取。</p><h2>环境配置</h2><p>一般在项目开发中，至少会经历过 <code>Dev</code> -> <code>Test</code>
      -> <code>Prod</code> 三个环境。如果再富余一点的话，还会再多一个 <code>Pre</code>
      环境。甚至在不差钱的情况下，每个环境可能都会有<strong>多套配置</strong>。那么对应的使用的数据库、<code>Redis</code>
      或者其他的配置项都会随着环境的变换而改变，所以在实际项目开发中，多环境的配置非常必要。</p><h4>自带环境配置</h4><p><code>NestJS</code>
      本身也自带了多环境配置方法</p><ol><li>安装 <code>@nestjs/config</code></li></ol><pre><code class="hljs language-ruby"><span class="hljs-variable">$ </span>yarn add  <span class="hljs-variable">@nestjs</span>/config</code></pre><ol
      start="2"><li>安装完毕之后，在 <code>app.module.ts</code> 中添加 <code>ConfigModule</code>
        模块</li></ol><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.controller'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.service'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user/user.module'</span>;<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ConfigModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/config'</span>;<span class="hljs-meta">@Module</span>({  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">ConfigModule</span>.<span class="hljs-title function_">forRoot</span>(), <span class="hljs-title class_">UserModule</span>],  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],})<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> { }</code></pre><p><code>@nestjs/config</code>
      默认会从<strong>项目根目录</strong>载入并解析一个 <code>.env</code> 文件，从 <code>.env</code>
      文件和 <code>process.env</code> 合并环境变量键值对，并将结果存储到一个可以通过 <code>ConfigService</code>
      访问的私有结构。</p><p><code>forRoot()</code> 方法注册了 <code>ConfigService</code>
      提供者，后者提供了一个 <code>get()</code> 方法来读取这些<strong>解析/合并</strong>的配置变量。</p><blockquote><p>当一个键同时作为环境变量（例如，通过操作系统终端如<code>export
          DATABASE_USER=test</code>导出）存在于运行环境中以及<code>.env</code>文件中时，以运行环境变量优先。</p></blockquote><p>默认的
      <code>.env</code> 文件变量定义如下所示，配置后会默认读取此文件:</p><pre><code class="hljs language-ini"><span class="hljs-attr">DATABASE_USER</span>=test<span class="hljs-attr">DATABASE_PASSWORD</span>=test</code></pre><h4>自定义
      YAML</h4><p>虽然 <code>Nest</code> 自带了环境配置的功能，使用的 <a
        href="https://github.com/motdotla/dotenv" target="_blank" rel="nofollow
        noopener noreferrer">dotenv</a> 来作为默认解析，但默认配置项看起来并不是非常清爽，我们接下来使用结构更加清晰的
      <code>YAML</code> 来覆盖默认配置。</p><blockquote><p>想要了解 <code>YAML</code>
        更多细节的同学可以点击<a href="https://baike.baidu.com/item/YAML/1067697"
          target="_blank" rel="nofollow noopener noreferrer">链接</a>看下，如果使用过
        <code>GitLab CICD</code> 的同学，应该对 <code>.yml</code> 文件比较熟悉了，这里我就不对 <code>YAML</code>
        配置文件做过多阐述了。</p></blockquote><ol><li>在使用自定义 <code>YAML</code> 配置文件之前，先要修改
        <code>app.module.ts</code> 中 <code>ConfigModule</code> 的配置项 <code>ignoreEnvFile</code>，禁用默认读取
        <code>.env</code> 的规则：</li></ol><pre><code class="hljs language-php">ConfigModule.<span class="hljs-title function_ invoke__">forRoot</span>({ <span class="hljs-attr">ignoreEnvFile</span>: <span class="hljs-literal">true</span>, });</code></pre><ol
      start="2"><li>然后再安装 <code>YAML</code> 的 <code>Node</code> 库 <code>yaml</code>：</li></ol><pre><code class="hljs language-csharp">$ yarn <span class="hljs-keyword">add</span> yaml</code></pre><ol
      start="3"><li>安装完毕之后，在根目录新建 <code>.config</code> 文件夹，并创建对应环境的 <code>yaml</code>
        文件，如下图所示：</li></ol><p><img
        src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e2c740648641b499440a0bd0038e31~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><ol start="4"><li>新建 <code>utils/index.ts</code>
        文件，添加读取 <code>YAML</code> 配置文件的方法：</li></ol><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { parse } <span class="hljs-keyword">from</span> <span class="hljs-string">'yaml'</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-comment">// 获取项目运行环境</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getEnv</span> = (<span class="hljs-params"></span>) => {  <span class="hljs-keyword">return</span> process.<span class="hljs-property">env</span>.<span class="hljs-property">RUNNING_ENV</span>}<span class="hljs-comment">// 读取项目配置</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getConfig</span> = (<span class="hljs-params"></span>) => {  <span class="hljs-keyword">const</span> environment = <span class="hljs-title function_">getEnv</span>()  <span class="hljs-keyword">const</span> yamlPath = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">`./.config/.<span class="hljs-subst">${environment}</span>.yaml`</span>)  <span class="hljs-keyword">const</span> file = fs.<span class="hljs-title function_">readFileSync</span>(yamlPath, <span class="hljs-string">'utf8'</span>)  <span class="hljs-keyword">const</span> config = <span class="hljs-title function_">parse</span>(file)  <span class="hljs-keyword">return</span> config}</code></pre><ol
      start="5"><li>最后添加在 <code>app.module.ts</code> 自定义配置项即可正常使用环境变量：</li></ol><pre><code class="hljs language-diff"><span class="hljs-addition">+ import { getConfig } from './utils';</span>    ConfigModule.forRoot({      ignoreEnvFile: true,<span class="hljs-addition">+     isGlobal: true,</span><span class="hljs-addition">+     load: [getConfig]</span>    }),</code></pre><blockquote><p>注意：<code>load</code>
        方法中传入的 <code>getConfig</code> 是一个函数，并不是直接 JSON 格式的配置对象，直接添加变量会报错。</p></blockquote><h4>使用自定义配置</h4><p>完成之前的配置后，就可以使用
      <code>cross-env</code> 指定运行环境来使用对应环境的配置变量。</p><ol><li>添加 cross-env 依赖：</li></ol><pre><code class="hljs language-shell"><span class="hljs-meta prompt_">$ </span><span class="bash">yarn add cross-env</span></code></pre><ol
      start="2"><li>修改启动命令：</li></ol><pre><code class="hljs language-json"><span class="hljs-attr">"start:dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-env RUNNING_ENV=dev nest start --watch"</span><span class="hljs-punctuation">,</span></code></pre><ol
      start="3"><li>添加 .dev.yaml 配置:</li></ol><pre><code class="hljs language-yaml"><span class="hljs-attr">TEST_VALUE:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">cookie</span></code></pre><blockquote><p>注意
        <code>yaml</code> 配置的规则，缩进以及冒号 <strong>:</strong> 后的空格是经常容易出错的地方</p></blockquote><ol
      start="4"><li>在我们之前创建好的 <code>UserController</code> 中添加 <code>ConfigService</code>
        以及新的请求：</li></ol><pre><code class="hljs language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> userService: UserService,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> configService: ConfigService  </span>) { }  <span class="hljs-meta">@Get</span>(<span class="hljs-string">'getTestName'</span>)  <span class="hljs-title function_">getTestName</span>(<span class="hljs-params"></span>) {    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">configService</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'TEST_VALUE'</span>).<span class="hljs-property">name</span>;  }}</code></pre><p>完成上述所有步骤之后，重启项目，接下来访问
      <a href="http://localhost:3000/v1/user/getTestName" target="_blank"
        rel="nofollow noopener noreferrer">http://localhost:3000/v1/user/getTestName</a>
      能看到已经能够根据环境变量拿到对应的值：</p><p><img
        src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc2fc65526944018b70040715cbcb340~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><blockquote><p>这里应该注意到，我们并没有注册 <code>ConfigModule</code>。这是因为在
        <code>app.module</code> 中添加 <code>isGlobal</code> 属性，开启 <code>Config</code>
        全局注册，如果 <code>isGlobal</code> 没有添加的话，则需要先在对应的 <code>module</code>
        文件中注册后才能正常使用 <code>ConfigService</code>。</p></blockquote><blockquote><p>项目配置的相关代码已上传
        <a href="https://github.com/boty-design/gateway/tree/demo/v3"
          target="_blank" rel="nofollow noopener noreferrer">demo/v3</a>
        分支中，需要的同学自取。由于 <code>.config</code> 里面的配置信息比较隐私，所以不会上传到 <code>git</code>
        当中，需要的同学可以在<a
          href="https://juejin.cn/book/7065201654273933316/section/7111992826132430859"
          target="_blank" rel="nofollow noopener noreferrer">第九章节-学习里程碑</a>中获取对应的模板。</p></blockquote><h2>热重载</h2><p><code>NestJS</code>
      的 <code>dev</code> 模式是将 <code>TS</code> 代码编译成 <code>JS</code>
      再启动，这样每次我们修改代码都会重复经历一次编译的过程。在项目开发初期，业务模块体量不大的情况下，性能开销并不会有很大的影响，但是在业务模块增加到一定数量时，每一次更新代码导致的重新编译就会异常痛苦。为了避免这个情况，<code>NestJS</code>
      也提供了热重载的功能，借助 <code>Webpack</code> 的 <code>HMR</code>，使得每次更新只需要替换更新的内容，减少编译的时间与过程。</p><blockquote><p>注意：<code>Webpack</code>并不会自动将（例如
        <code>graphql</code> 文件）复制到 <code>dist</code> 文件夹中。同理，<code>Webpack</code>
        与静态路径（例如 <code>TypeOrmModule</code> 中的 <code>entities</code>
        属性）不兼容。所以如果有同学跳过本章，直接配置了 <code>TypeOrmModule</code> 中的 <code>entities</code>，反过来再直接配置热重载会导致启动失败。</p></blockquote><p>由于我们是使用
      <code>CLI</code> 插件安装的工程模板，可以直接使用 <code>HotModuleReplacementPlugin</code>
      创建配置，减少工作量。</p><ol><li>照例安装所需依赖：</li></ol><pre><code class="hljs language-arduino">$ yarn add webpack-node-externals run-script-webpack-plugin webpack</code></pre><ol
      start="2"><li>根目录新建 <code>webpack-hmr.config.js</code> 文件，复制下述代码：</li></ol><pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nodeExternals = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-node-externals'</span>);<span class="hljs-keyword">const</span> { <span class="hljs-title class_">RunScriptWebpackPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'run-script-webpack-plugin'</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options, webpack</span>) {  <span class="hljs-keyword">return</span> {    ...options,    <span class="hljs-attr">entry</span>: [<span class="hljs-string">'webpack/hot/poll?100'</span>, options.<span class="hljs-property">entry</span>],    <span class="hljs-attr">externals</span>: [      <span class="hljs-title function_">nodeExternals</span>({        <span class="hljs-attr">allowlist</span>: [<span class="hljs-string">'webpack/hot/poll?100'</span>],      }),    ],    <span class="hljs-attr">plugins</span>: [      ...options.<span class="hljs-property">plugins</span>,      <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>(),      <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">WatchIgnorePlugin</span>({        <span class="hljs-attr">paths</span>: [<span class="hljs-regexp">/.js$/</span>, <span class="hljs-regexp">/.d.ts$/</span>],      }),      <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunScriptWebpackPlugin</span>({ <span class="hljs-attr">name</span>: options.<span class="hljs-property">output</span>.<span class="hljs-property">filename</span> }),    ],  };};</code></pre><ol
      start="3"><li>修改 <code>main.ts</code>，开启 <code>HMR</code> 功能：</li></ol><pre><code class="hljs language-ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">module</span>: <span class="hljs-built_in">any</span>;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) {    <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>();    <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">dispose</span>(<span class="hljs-function">() =></span> app.<span class="hljs-title function_">close</span>());  }}<span class="hljs-title function_">bootstrap</span>();</code></pre><ol
      start="4"><li>修改启动脚本启动命令即可：</li></ol><pre><code class="hljs language-less">"start:hotdev": "cross-env RUNNING_ENV=dev nest build <span class="hljs-attr">--webpack</span> <span class="hljs-attr">--webpackPath</span> webpack-hmr.config.js <span class="hljs-attr">--watch</span>"</code></pre><p><img
        src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7b960fe772e404cbac3276e5e167db9~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>然后修改一段简单的代码（随意修改即可），测试一下热更新的是否正常生效：</p><p><img
        src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659b2d68c1d145d1b3a7f5bfff96ee98~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><p>如上图所示，我们已经开启了 <code>HMR</code>
      功能，具体什么时候使用可以根据自己的项目以及喜好开启，如果没有使用 <code>CLI</code> 创建的工程模板，但也想开启 <code>HMR</code>
      功能的话，可以根据<a
        href="https://docs.nestjs.cn/8/recipes?id=%e6%b2%a1%e6%9c%89%e4%bd%bf%e7%94%a8-cli"
        target="_blank" rel="nofollow noopener noreferrer">文档</a> 自行配置。</p><blockquote><p>热更新的功能看自己的需求再开启，有的时候存在缓存的情况出现，<strong>另外，在使用热更新的时候，数据库章节中实体类需要手动注册，不能自动注册</strong>，所以如果项目不大的啥情况，使用
        <strong>NestJS</strong> 自带的项目启动脚本即可。</p></blockquote><h2>文档</h2><p>作为一个后端服务，<strong>API</strong>
      文档是必不可少的，除了接口描述、参数描述之外，自测也十分方便。<code>NestJS</code> 自带了 <code>Swagger</code>
      文档，集成非常简单，接下来进行文档的配置部分。</p><ol><li>工程之前使用了 <code>fastify</code>
        所以需要安装以下依赖：</li></ol><pre><code class="hljs language-ruby"><span class="hljs-variable">$ </span>yarn add <span class="hljs-variable">@nestjs</span>/swagger </code></pre><blockquote><p>新版本已经不需要安装
        fastify-swagger 依赖，默认被内置在 <code>@nestjs/swagger</code> 中了。</p></blockquote><ol
      start="2"><li>依赖安装完毕之后，先创建 <code>src/doc.ts</code> 文件：</li></ol><pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">SwaggerModule</span>, <span class="hljs-title class_">DocumentBuilder</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/swagger'</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> packageConfig <span class="hljs-keyword">from</span> <span class="hljs-string">'../package.json'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">generateDocument</span> = (<span class="hljs-params">app</span>) => {  <span class="hljs-keyword">const</span> options = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DocumentBuilder</span>()    .<span class="hljs-title function_">setTitle</span>(packageConfig.<span class="hljs-property">name</span>)    .<span class="hljs-title function_">setDescription</span>(packageConfig.<span class="hljs-property">description</span>)    .<span class="hljs-title function_">setVersion</span>(packageConfig.<span class="hljs-property">version</span>)    .<span class="hljs-title function_">build</span>();  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">document</span> = <span class="hljs-title class_">SwaggerModule</span>.<span class="hljs-title function_">createDocument</span>(app, options);  <span class="hljs-title class_">SwaggerModule</span>.<span class="hljs-title function_">setup</span>(<span class="hljs-string">'/api/doc'</span>, app, <span class="hljs-variable language_">document</span>);}</code></pre><blockquote><p>为了节约配置项，<code>Swagger</code>
        的配置信息全部取自 <code>package.json</code>，有额外需求的话可以自己维护配置信息的文件。</p></blockquote><p>默认情况下，在
      <code>TS</code> 开发的项目中是没办法导入 <code>.json</code> 后缀的模块，所以可以在 <code>tsconfig.json</code>
      中新增 <code>resolveJsonModule</code> 配置即可。</p><pre><code class="hljs language-diff">{  "compilerOptions": {    "module": "commonjs",    "declaration": true,    "removeComments": true,    "emitDecoratorMetadata": true,    "experimentalDecorators": true,    "allowSyntheticDefaultImports": true,    "target": "es2017",    "sourceMap": true,    "outDir": "./dist",    "baseUrl": "./",    "incremental": true,    "skipLibCheck": true,    "strictNullChecks": false,    "noImplicitAny": false,    "strictBindCallApply": false,    "forceConsistentCasingInFileNames": false,    "noFallthroughCasesInSwitch": false,<span class="hljs-addition">+   "resolveJsonModule": true</span>  }}</code></pre><ol
      start="4"><li>在 <code>main.ts</code> 中引入方法即可：</li></ol><pre><code class="hljs language-diff">import { VersioningType, VERSION_NEUTRAL } from '@nestjs/common';import { NestFactory } from '@nestjs/core';import {  FastifyAdapter,  NestFastifyApplication,} from '@nestjs/platform-fastify';import { AppModule } from './app.module';import { AllExceptionsFilter } from './common/exceptions/base.exception.filter';import { HttpExceptionFilter } from './common/exceptions/http.exception.filter';import { TransformInterceptor } from './common/interceptors/transform.interceptor';<span class="hljs-addition">+ import { generateDocument } from './doc';</span>declare const module: any;async function bootstrap() {  const app = await NestFactory.create&#x3C;NestFastifyApplication>(    AppModule,    new FastifyAdapter(),  );  // 统一响应体格式  app.useGlobalInterceptors(new TransformInterceptor());  // 异常过滤器  app.useGlobalFilters(new AllExceptionsFilter(), new HttpExceptionFilter());  // 接口版本化管理  app.enableVersioning({    defaultVersion: [VERSION_NEUTRAL, '1', '2'],    type: VersioningType.URI,  });<span class="hljs-addition">+  // 创建文档</span><span class="hljs-addition">+  generateDocument(app)</span>  // 添加热更新  if (module.hot) {    module.hot.accept();    module.hot.dispose(() => app.close());  }  await app.listen(3000);}bootstrap();</code></pre><p>完成上述内容之后，浏览器打开
      <a href="http://localhost:3000/api/doc" target="_blank" rel="nofollow
        noopener noreferrer">http://localhost:3000/api/doc</a> 就能看到 <code>Swagger</code>
      已经将我们的前面写好的接口信息收集起来了。</p><p><img
        src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777e652772fe47ce8ea0ac87dd17812e~tplv-k3u1fbpfcp-watermark.image?"
        alt="image.png"></p><blockquote><p>从上图可以看出，<code>Swagger</code>
        会默认收集我们的接口信息，但是没有描述与分类，使用上很不方便，由于使用过程中的细节较多，具体的配置细节可以从<a
          href="https://docs.nestjs.cn/8/recipes?id=swagger" target="_blank"
          rel="nofollow noopener noreferrer">官网文档</a>获取。</p></blockquote><blockquote><p>热更新与
        <code>Swagger</code> 文档配置代码以上传 <a
          href="https://github.com/boty-design/gateway/tree/demo/v4"
          target="_blank" rel="nofollow noopener noreferrer">demo/v4</a>，需要的同学可以自取。</p></blockquote><h2>写在最后</h2><p>本章主要介绍了，对
      <code>CLI</code> 创建的标准工程模板进行一些常规项目必备的功能配置，例如替换底层 <code>HTTP</code>
      框架、环境变量配置等等内容。</p><p>添加了上述<strong>通用性基础配置</strong>后的工程模板能基本满足一个小型的业务需求，如果还有其他要求的话可以增减功能或者修改某些配置来适配，总体还是看<strong>团队自身的业务需求来定制</strong>，比如团队中有<code>统一权限控制的插件</code>或者<code>构建服务的脚本</code>都可以放在工程模板中，方便其他同学开箱即用。</p><p>现在，我们已经对
      <code>NestJS</code> 有了初步了解。下一章，我们将正式使用 <code>NestJS</code> 开发业务需求。</p><p>如果你有什么疑问，欢迎在评论区提出或者加群沟通。
      👏</p>
  </body>
</html>