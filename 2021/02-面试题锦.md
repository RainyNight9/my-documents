# 面试题锦

## 1、JS事件循环

* JS是单线程语言：顺序执行

* 任务队列

```js
let data = [];
$.ajax({
  url:www.javascript.com,
  data:data,
  success:() => {
    console.log('发送成功!');
  }
})
console.log('代码执行结束');
```

* setTimeout

```js
setTimeout(() => {
  task()
},3000)

sleep(10000) // sleep为一个同步任务，10000为执行时间
```

>注：即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

* Promise

Promise 新建后就会立即执行。

* 宏任务和微任务

  * macro-task(宏任务)：整体代码script，setTimeout，setInterval
  * micro-task(微任务)：Promise

>注：在事件循环中，永远先执行可执行的微任务

```js
setTimeout(function(){
  console.log('1')
});

new Promise(function(resolve){
  console.log('2');
  for(var i = 0; i < 10000; i++){
    i == 99 && resolve();
  }
}).then(function(){
  console.log('3')
});

console.log('4');
```

```js
console.log('1');

setTimeout(function () {
  console.log('2');
  new Promise(function (resolve) {
    console.log('3');
    resolve();
  }).then(function () {
    console.log('4')
  })
})

new Promise(function (resolve) {
  console.log('5');
  resolve();
}).then(function () {
  console.log('6')
})

setTimeout(function () {
  console.log('7');
  new Promise(function (resolve) {
    console.log('8');
    resolve();
  }).then(function () {
    console.log('9')
  })
})
```

## 2、函数柯里化

* 什么是函数柯里化？

```js
function multiply(a, b, c) {
  return a * b * c;
}
multiply(1, 2, 3); // 6

// 柯里化后：
function multiply(a) {
  return (b) => {
    return (c) => {
      return a * b * c
    }
  }
}
multiply(1)(2)(3) // 6
```

通过把一个多参函数转换成一系列嵌套的函数，每个函数依次接受一个参数，这就是函数柯里化。

```js
let _fn = curry(function (a, b, c, d, e) {
  console.log(a + b + c + d + e)
});
console.log(_fn);

_fn(1, 2, 3, 4, 5);  // 15
_fn(1)(2)(3, 4, 5);  // 15
_fn(1, 2)(3, 4)(5);  // 15
_fn(1)(2)(3)(4)(5);  // 15
function curry(fn, len = fn.length) {
  return _curry.call(this, fn, len)
}


function _curry(fn, len, ...args) {
  return function (...params) {
    console.log(params);
    let _args = [...args, ...params];
    console.log(_args);
    if (_args.length >= len) {
      return fn.apply(this, _args);
    } else {
      return _curry.call(this, fn, len, ..._args)
    }
  }
}
```

## 3、add(1,2)(3)(4,5) // 15 (字节原题)

要求如下：

```js
const add3  = add(0, 1)(2) // add3的功能是对传入的数值加3并返回
console.log(  add3(2) + 0  ) // log出5
const add8  = add3(1)(2)(2) // add8由add3的持续调用得到
const add8p = add3(5) // 另一种方式得到add8，注意两个add8不是同一个函数，起名add8p
const add9  = add8(1) // 由add8再传入得到add9函数
console.log(  add9(1) + 3  ) // log出13
console.log(  add8(1) + 3  ) // log出12
/*
注意以上代码中的add，add3，add8，add8p，add9都是不同的函数，且每个函数要加的数是不一样的。
*/
```

答案如下：

```js
function add(...args) {

  // 将参数绑定到add上
  // 此时f其实还是add函数，但已经固定了一些参数，所以并不是原来的add函数
  // 用bind返回新函数以保证满足**柯里化保留参数**的特性
  var f = add.bind(null/*this不用绑定*/, ...args) 

  // 重新实现这个bound add函数的toString方法
  // f参与运算应该被当成args的和，与f自己再接收的参数无关
  // 考虑到lazy的特性，还是需要时再计算，但又没了缓存，每次用都会重新计算
  // 如果有需要，可以改成有缓存的版本
  f.toString = () => {
    return args.reduce((a, b) => a + b, 0)
  }

  return f
}

// 考虑到add可能直接被用于运算中，可以加上这句
add.toString = () => 0
```

本题解来自知乎大佬[谢然](https://zhuanlan.zhihu.com/p/296852112)

## 4、React Hooks 模拟出几个常用的生命周期 （字节原题）

```js
useEffect(() => {
  // 组件挂载后执行事件绑定
  console.log('on')
  addEventListener()

  // 组件 update 时会执行事件解绑
  return () => {
    console.log('off')
    removeEventListener()
  }
}, [source]);


// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):
// --- DidMount ---
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- WillUnmount --- 
// 'off'
```

通过第二个参数，我们便可模拟出几个常用的生命周期:

* componentDidMount: 传入[]时，就只会在初始化时调用一次；

```js
const useMount = (fn) => useEffect(fn, [])
```

* componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次；

```js
const useUnmount = (fn) => useEffect(() => fn, [])
```

* mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；

```js
const useMounted = () => {
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    !mounted && setMounted(true);
    return () => setMounted(false);
  }, []);
  return mounted;
}
```

* componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；

```js
const mounted = useMounted() 
useEffect(() => {
  mounted && fn()
})
```

另外可参考：

1、[React Hooks 介绍及与传统 class 组件的生命周期函数对比
](https://blog.csdn.net/u014607184/article/details/109744910)

2、[使用React Hooks模拟生命周期
](https://juejin.cn/post/6844903921442373639)

## 5、sass与less区别

[Sass和less的区别是什么？用哪个好](https://www.cnblogs.com/pink-chen/p/10727915.html)

## 6、canvas和svg区别

***SVG***

* SVG 是一种使用 XML 描述 2D 图形的语言。

* SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。

* 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

***Canvas***

* Canvas 通过 JavaScript 来绘制 2D 图形。

* Canvas 是逐像素进行渲染的。

* 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

***Canvas 与 SVG 的比较***

Canvas:

* 依赖分辨率
* 不支持事件处理器
* 弱的文本渲染能力
* 能够以 .png 或 .jpg 格式保存结果图像
* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

SVG:

* 不依赖分辨率
* 支持事件处理器
* 最适合带有大型渲染区域的应用程序（比如谷歌地图）
* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
* 不适合游戏应用

## 7、了解可视化框架

***1、D3.js***

D3 的全称是（Data-Driven Documents）。D3 .js是一个JavaScript库（是一个被数据驱动的文档），用于在浏览器中创建交互式可视化。

D3.js库允许我们在数据集的上下文中操作网页的元素.这些元素可以是HTML，SVG，或画布元素，可以根据数据集的内容进行引入，删除或编辑.它是一个用于操作DOM对象的库. D3.js可以成为数据探索的宝贵帮助，它可以让您控制数据的表示，并允许您添加交互性.

***2、highcharts***

Highcharts 是一个用纯JavaScript编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表,HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。

***3、echarts***

ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。

***4、兼容性***

Highcharts 兼容 IE6 及以上的所有主流浏览器，完美支持移动端缩放、手势操作。

Echarts 兼容 IE6 及以上的所有主流浏览器，同样支持移动端的缩放和手势操作。

D3 兼容IE9 及以上的所有主流浏览器，对于移动端的兼容性也同上。

也就是说，这三个插件都兼容IE9及以上的所有主流浏览器，但如果开发需求中包括IE7/IE8，那么就只能选择Highcharts或者Echarts了。

***5、是否免费/开源***

Highcharts 非商业免费，商业需授权，代码开源。

Echarts 完全免费，代码开源。

D3 完全免费，代码开源。

***6、难度***

Highcharts 基于SVG，方便自己定制，但图表类型有限。

Echarts 基于Canvas，适用于数据量比较大的情况。

D3.v3 基于SVG，方便自己定制；D3.v4支持Canvas+SVG，如果计算比较密集，也可以选择用Canvas。除此之外，D3图表类型非常丰富，几乎可以满足所有开发需求，但代码相对于以上两个插件来说，会稍微难一点。

***7、性能优化***

在同一图层内，可以容纳大量数据绘制，性能较好，但不支持每个对象的变化

不同图层，大量数据绘制效果较差，但支持每个对象的变化

最差的情况，每次删除所有图层，再创建图层，重新绘制

***8、正确理解Repaint和Reflow***

Repaint 和 Reflow 也就是重绘和重排，Repaint(重绘)就是在一个元素的外观被改变，但没有改变布局(宽高)的情况下发生，如改变visibility、outline、背景色等等。

Reflow(重排)就是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证DOM树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如：改变窗囗大小、改变文字大小、内容的改变、浏览器窗口变化，style属性的改变等等。如果Reflow的过于频繁，CPU使用率就会噌噌的往上涨，所以前端也就有必要知道 Repaint 和 Reflow的知识。

上面提到通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow，所以最好通过设置class的方式；有动画效果的元素，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局；如果功能需求上不能设置position为fixed或absolute，那么就权衡速度的平滑性。

总之，因为 Reflow 有时确实不可避免，所以只能尽可能限制Reflow的影响范围。

## 8、Grunt，Gulp、Webpack、Rollup、Parcel 区别

>四款前端主流的打包工具：grunt， gulp，webpack， rollup，以发布时间为顺序。

***Grunt：***

* 一句话：自动化。对于需要反复重复的任务，例如压缩（minification）、编译、单元测试、linting 等，自动化工具可以减轻你的劳动，简化你的工作。
* 当你在 Gruntfile 文件正确配置好了任务，任务运行器就会自动帮你或你的小组完成大部分无聊的工作。
* 最老牌的打包工具，他运用配置的思想来写打包脚本，一切皆配置，所以会出现比较多的配置项，诸如option,src,dest等等
* [gruntjs](https://www.gruntjs.net)

优点

  出现的比较早

缺点

  配置项太多
  而且不同的插件可能会有自己扩展字段
  学习成本高，运用的时候需要明白各种插件的配置规则和配合方式

安装

```sh
npm i grunt  grunt-babel @babel/core @babel/preset-env -D
```

***Gulp：***

* gulp 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。
* 基于 nodejs 的 steam 流打包
* 定位是基于任务流的自动化构建工具
* gulp 是通过 task 对整个开发过程进行构建

优点

  用代码方式来写打包脚本，流式的写法，简单直观，只抽象出了gulp.src, gulp.pipe, gulp.dest, gulp.watch 接口，运用相当简单
  API 简单，代码量少，使用gulp的代码量能比grunt少一半左右
  易于学习和使用
  适合多页面应用开发

缺点

  异常处理比较麻烦
  工作流程顺序难以精细控制
  不太适合单页或者自定义模块的开发

```sh
cnpm install --save-dev gulp-cli gulp gulp-babel @babel/core @babel/preset-env
```

***webpack:***

* webpack 是模块化管理工具和打包工具。通过 loader 的转换，任何形式的资源都可以视作模块，比如 Commonjs 模块、AMD 模块、ES6 模块、css、图片等。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源
* 还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载
* 它定位是模块打包器，而 gulp 和 grunt 属于构建工具，webpack 可以代替它们的一切功能，但不是一个职能的工具，可以配合使用

优点

  可以模块化的打包任何资源
  适配任何模块系统
  适合SPA单页应用的开发

缺点

  学习成本高，配置复杂
  通过babel的编译后的js代码打包后体积过大

```sh
npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env -D
```

***Rollup：***

Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。

Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。

* rollup 下一代 ES6 模块化工具，最大的亮点是利用 ES6 模块设计，利用 tree-shaking 生成更简洁、更简单的代码
* 一般而言，对于应用使用 webpack，对于类库使用 rollup
* 需要代码拆分（code splitting），或者很多静态资源需要处理，再或者构建的项目需要引入很多 Commonjs 模块的依赖时，使用 webpack
* 代码库是 基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 rollup

## 优点

  用标准化的格式（es6）来写代码，通过减少死代码尽可能的缩小包体积

## 缺点

  对代码拆分、静态资源、commonjs模块支持不好

https://www.rollupjs.com/guide/tools/#babel

***Parcel***

* [Parcel](https://parceljs.org/getting_started.html)
  内置了一个开发服务器，这会在你更改文件时自动重建你的应用程序，并支持模块热替换 ，以便你快速开发。你只需指定入口文件即可，打包入口也不仅仅只是JS
* 零配置 快，其打包速度也要比Webpack快
* parcel 是快速、零配置的 web 应用程序打包器
* 目前 parcel 只能用来构建用于运行在浏览器中的网页，这也是他的出发点和专注点

优点

  parcel 内置了常见场景的构建方案及其依赖，无需再安装各种依赖
  parcel 能以html为入口，自动检测和打包依赖资源
  parcel 默认支持模块热替换，真正的开箱即用

缺点

  不支持SourceMap
  不支持剔除无效代码（tree-shaking）
  配置不灵活

安装

```sh
yarn global add parcel-bundler
npm install -g parcel-bundler

parcel -V
```

==使用总结：==

***Grunt：***

MPA，老牌打包工具，基于文件为媒介（运行慢，零散的脚本文件一当多起来就受到影响

***Gulp：***

MPA，易学，基于 nodejs 的 steam 流打包

***Webpack：***

SPA，目前最强大的打包工具，但是过于臃肿，如何单纯打包js不推荐

常用loader：
    - babel-loader 把 ES6 转换成 ES5
    - css-loader 加载 CSS，支持模块化、压缩、文件导入等特性
    - eslint-loader 通过 ESLint 检查 JavaScript 代码
    - file-loader 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
    - postcss-loader 网页包的加载器，用于使用PostSS处理CSS
    - resolve-url-loader 基于原始源文件重写url（）语句中相对路径的网页包加载程序。
    - sass-loader 加载Sass/SCSS文件并将其编译为CSS。
    - style-loader 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
    - url-loader  和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去

***Roleup：***

MPA，tree-shaking特性（针对es6，按需打包，多余的不要，目前（2018，vuex,react主流使用）

***Parcel***

虽然Parcel相比Webpack似乎具有更多优势，但它毕竟还不够成熟，没有Webpack庞大的社区，一旦遇到问题很难在网上快速找到相应解决办法。

## 9、JSBridge实现原理

```js
class JsBridge {
  static lastCallTime
  constructor() {
    if (UA.isReactNative()) {
      document.addEventListener('message', function (e) {
        window.jsClientCallBack[e.data.cbName](e.data.param);
      });
    }
  }
  // 通用callNative方法
  callClient(functionName, data, callback) {
    // 避免连续调用
    if (JsBridge.lastCallTime && (Date.now() - JsBridge.lastCallTime) < 100) {
      setTimeout(() => {
        this.callClient(functionName, data, callback);
      }, 100);
      return;
    }
    JsBridge.lastCallTime = Date.now();

    data = data || {};
    if (callback) {
      const cbName = randomName();
      Object.assign(data, { cbName });
      window.jsClientCallBack[cbName] = callBack.bind(this);
    }

    if (UA.isIOS()) {
      data.forEach((key, value) => {
        try {
          data[key] = JSON.stringify(value);
        } catch (e) { }
      });
      var url = 'jsbridge://' + functionName + '?' parseJSON(data);
      var iframe = document.createElement('iframe');
      iframe.style.width = '1px';
      iframe.style.height = '1px';
      iframe.style.display = 'none';
      iframe.src = url;
      document.body.appendChild(iframe);
      setTimeout(() => {
        iframe.remove();
      }, 100);
    } else if (UA.isAndroid()) { // 这里安卓客户端使用的是上面说的第二种通信方法
      window.AndroidNativeApi &&
        window.AndroidNativeApi[functionName] &&
        window.AndroidNativeApi[functionName](JSON.stringify(data));
    } else if (UA.isReactNative()) { // rn的<webView>组件可以设置props.userAgent来让H5识别
      window.postMessage(
        JSON.stringify(data);
          );
    } else {
      console.error('未获取platform信息，调取api失败');
    }
  }
  // 业务层自定义方法
  getShare(data, callBack) {
    //..
  }
}
```

参考自： [H5如何与原生App通信？](https://juejin.cn/post/6885988193402159118)

## 10、链表

## 11、字符串

## 12、promise

```js
class MyPromise {
  constructor(executor) {
    this.initValue()
    this.initBind()
    try {
      executor(this.resolve, this.reject)
    } catch (e) {
      this.reject(e)
    }
  }
  initValue() {
    this.PromiseState = 'pending'
    this.PromiseResult = null
    this.onFulfilledCallbacks = []
    this.onRejectedCallbacks = []
  }
  initBind() {
    this.resolve = this.resolve.bind(this)
    this.reject = this.reject.bind(this)
  }
  resolve(value) {
    if (this.PromiseState !== 'pending') return
    this.PromiseState = 'fulfilled'
    this.PromiseResult = value
    while (this.onFulfilledCallbacks.length) {
      this.onFulfilledCallback.shift()(this.PromiseResult)
    }
  }
  reject(reason) {
    if (this.PromiseState !== 'pending') return
    this.PromiseState = 'rejected'
    this.PromiseResult = reason
    while (this.onRejectedCallbacks.length) {
      this.onRejectedCallbacks.shift()(this.PromiseResult)
    }
  }
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }
    let thenPromise = new MyPromise(() => {
      const resolvePromise = cb => {
        setTimeout(()=>{
          try {
            const x = cb(this.PromiseResult)
            if (x === thenPromise) {
              throw new Error('不能返回自身...')
            }
            if (x instanceof MyPromise) {
              x.then(resolve, reject)
            } else {
              resolve(x)
            }
          } catch (e) {
            reject(e)
          }
        })
      }
      if (this.PromiseState === 'fulfilled') {
        // onFulfilled(this.PromiseState)
        resolvePromise(onFulfilled)
      } else if (this.PromiseState === 'rejected') {
        // onRejected(this.PromiseState)
        resolvePromise(onRejected)
      } else if (this.PromiseState === 'pending') {
        // this.onFulfilledCallbacks.push(onFulfilled.bind(this))
        // this.onRejectedCallbacks.push(onRejected.bind(this))
        this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
        this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
      }
    })
    return thenPromise
  }
}
```

## 13、节流和防抖

```js
// 节流
const throttle = (fn, delay = 500) => {
  let flag = true;
  return (...args) => {
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(this, args);
      flag = true;
    }, delay);
  };
};

// 防抖
const debounce = (fn, delay) => {
  let timer = null;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
};

const debounce = (fn, time) => {
  let timer = null
  return (...args)=>{
    clearTimeout(timer)
    timer = setTimeout(()=>{
      fn.apply(this, args)
    }, time)
  }
}
```

## 14、Composition API与React Hook很像，说说区别

从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制：
  
* 不能在循环、条件、嵌套函数中调用Hook
* 必须确保总是在你的React函数的顶层调用Hook
* useEffect、useMemo等函数必须手动确定依赖关系

而Composition API是基于Vue的响应式系统实现的，与React Hook的相比：

* 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢
* Composition API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用
* 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。

虽然Composition API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。

## 15、二叉树遍历

## 16、css 实现高度是父盒子宽度一半的盒子，可以等比例变化（css）（字节原题）

缩放

## 17、padding-left 和 padding-top 的值是怎么计算的（css）（字节原题）

是相对于父元素的width计算的

## 18、flex 九宫格（css）（字节原题）

## 19、实现类似模版字符串的解析 （JS）（字节原题）

```js
let templateStr = 'i am {{name}},age {{age}},job {{job}} ';
let data = {
  name: 'xbd',
  age: 18,
  job: 'CTO'
}

function templateFunc(str, data) {
  let computed = str.replace(/\{\{(\w+)\}\}/g, function (match, key) {
    return data[key];
  })
  return computed;
}

console.log(templateFunc(templateStr, data));
```

## 20、手写reduce

```js
Array.prototype.reduce = function (fn, init) {
  var arr = this   // this就是调用reduce方法的数组
  var total = init || arr[0]   // 有初始值使用初始值
  // 有初始值的话从0遍历， 否则从1遍历
  for (var i = init ? 0 : 1; i < arr.length; i++) {
    total = fn(total, arr[i], i, arr)
  }
  return total
}
var arr = [1, 2, 3]
console.log(arr.reduce((prev, item) => prev + item, 10)) 
```

## 21、谈谈vue和react的区别和优劣

## 22、fn([['a', 'b'], ['n', 'm'], ['0', '1']]) => ['an0', 'am0', 'an1', 'am1', 'bn0', 'bm0', 'bn1', 'bm0']

```js
function f(matrix) {
  const result = [];
  const len = matrix.length;
  function dfs(res, cur) {
    if (res.length === len) {
      result.push(res.join(''));
      return;
    }
    for (let i = 0; i < matrix[cur].length; i++) {
      res.push(matrix[cur][i]);
      dfs(res, cur + 1);
      res.pop();
    }
  }
  dfs([], 0);
  return result;
}

console.log(f([['a', 'b'], ['n', 'm'], ['0', '1']]))
```

## 23、u.console('breakfast').setTimeout(3000).console('lunch').setTimeout(3000).console('dinner')，实现这个u

```js
class U {
  constructor() {
    this.promise = Promise.resolve();
  }
  console(val) {
    this.promise = this.promise.then(() => {
      console.log(val);
    });
    return this;
  }
  setTimeout(wait) {
    this.promise = this.promise.then(() => {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve()
        }, wait);
      });
    })
    return this;
  }
}
const u = new U()
u.console('breakfast').setTimeout(3000).console('lunch').setTimeout(3000).console('dinner')
````

## 24、从输入Url到页面渲染发生了什么？写个提纲

* 网络阶段：构建请求行、查询强缓存、DNS解析、建立TCP连接、发送HTTP请求、响应请求
* 解析阶段：解析html、构建dom树、计算样式、生成布局树
* 渲染阶段：生成图层树、生成绘制列表、生成图块、优先选择视口附近的图块生成位图数据、展示内容

## 25、输出

```js
var length = 10;
function fn() {
  console.log(this.length + 1)
  return this.length + 1;
}
var obj1 = {
  length: 5,
  test1: function () {
    return fn()
  }
}
obj1.test2 = fn;

obj1.test1.call()
obj1.test1() 
obj1.test2.call()
obj1.test2() 

// 11
// 11
// 11
// 6
```

## SSR有了解吗？原理是什么？

在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。

而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据以外，HTML结构也已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。

使用SSR的好处：

有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。

白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。

## 在Vue3.0优雅的使用v-model

在Vue2.0中如何实现双向数据绑定：

一种是v-model，另一种是.sync。

因为一个组件只能用于一个v-model，但是有的组件需要有多个可以双向响应的数据，所以就出现了.sync。

在Vue3.0中为了实现统一，实现了让一个组件可以拥有多个v-model，同时删除掉了.sync。

在vue3.0中，v-model后面需要跟一个modelValue，即要双向绑定的属性名，Vue3.0就是通过给不同的v-model指定不同的modelValue来实现多个v-model。

参考地址: https://v3.vuejs.org/guide/migration/v-model.html#overview

## 深度优先遍历

```js
// 1.深度优先遍历的递归写法 
function deepTraversal(node) {
  let nodes = []
  if (node != null) {
    nodes.push(node)
    let childrens = node.children
    for (let i = 0; i < childrens.length; i++)
      deepTraversal(childrens[i])
  }
  return nodes
}
// 2.深度优先遍历的非递归写法 
function deepTraversal(node) {
  let nodes = []
  if (node != null) {
    let stack = [] // 同来存放将来要访问的节点 
    stack.push(node)
    while (stack.length != 0) {
      let item = stack.pop() // 正在访问的节点 
      nodes.push(item)
      let childrens = item.children
      // 将现在访问点的节点的子节点存入 stack，供将来访问
      for (let i = childrens.length - 1; i >= 0; i--)
        stack.push(childrens[i])
    }
  }
  return nodes
}
return nodes}
```

## 广度优先遍历

```js
// 3.广度优先遍历的递归写法 
function wideTraversal(node) {
  let nodes = [], i = 0
  if (node != null) {
    nodes.push(node)
    wideTraversal(node.nextElementSibling)
    node = nodes[i++]
    wideTraversal(node.firstElementChild)
  }
  return nodes
}
// 4.广度优先遍历的非递归写法 
function wideTraversal(node) {
  let nodes = [], i = 0
  while (node != null) {
    nodes.push(node)
    node = nodes[i++]
    let childrens = node.children
    for (let i = 0; i < childrens.length; i++) {
      nodes.push(childrens[i])
    }
  }
  return nodes
}
```

## css上下左右居中

## 继承

### 原型链继承

```
function Parent (sex) {
    this.sex = sex
}

Parent.prototype.setSex = function () {}

function Son (name) {
    this.name = name
}

Son.prototype = new Parent()
var s1 = new Son('DBCDouble')
console.log(s1)

```

关键：把子类的原型指向父类的实例，从而继承父类的私有属性和原型属性

优点：

    父类新增原型属性和方法，子类实例都能访问到
    
    简单、易用
    
缺点：

    无法实现多继承（一个子类继承成多个父类）
    
    创建子类实例的时候，无法向父类构造函数传参
    
    有子类实例共享父类引用属性的问题（因为子类的原型指向的是父类的一个实例，假如父类的私有属性有一个是数组(引用类型)，那么任一子类都可以操作这个数组，从而导致其他子类使用的这个数组也会发生变化）

### 借用父类构造函数继承

```
function Parent (sex) {
    this.sex = sex
}

Parent.prototype.setSex = function () {}

function Son (name, age, sex) {
    Parent.call(this, sex)
    this.name = name
    this.age = age
}
var s1 = new Son('DBCdouble', 25, '男')
console.log(s1)


```

关键：在子类构造函数中使用call或者apply调用父类构造函数实现父类私有属性继承（函数复用）

优点：

    创建子类实例时，可以向父类传递参数  
    
    可以实现多继承（在子类构造函数调用多个父类构造函数）
    
    解决了原型链继承中子类实例共享父类引用属性的问题（即使父类构造函数中有引用类型，在创建子类实例时，都会重新调用父类构造函数重新创建一份这个引用类型数据，重新申请引用类型的空间）

缺点：

    每次创建子类实例时，都要调用一次父类构造函数，影响性能
    
    只继承父类的实例属性(私有属性)，没有继承父类的原型属性

### 组合式继承(原型链继承 + 借用构造函数继承)

```
function Parent (sex) {
    this.sex = sex
}

Parent.prototype.setSex = function () {}

function Son (name, age, sex) {
    Parent.call(this, sex)
    this.name = name
    this.age = age
}
Son.prototype = Object.create(Parent.prototype)
Son.prototype.constructor = Son
var s1 = new Son('DBCdouble', 25, '男')
console.log(s1)
```

关键：通过调用父类构造函数，继承父类的属性并保留传参的优点，并通过Object.create(Parent.prototype)来创建继承了父类原型属性的对象，并把这个对象赋给子类的原型，这样的话，既能保证父类构造函数不用执行两次，又能让子类能继承到父类的原型方法

优点：

    创建子类实例时，可以向父类传递参数  
    
    可以实现多继承（在子类构造函数调用多个父类构造函数）
    
    解决了原型链继承中子类实例共享父类引用属性的问题（即使父类构造函数中有引用类型，在创建子类实例时，都会重新调用父类构造函数重新创建一份这个引用类型数据，重新申请引用类型的空间）  
    
    父类构造函数只用执行一次

### ES6的class继承

```
class A {
  constructor (sex) {
    this.sex = sex
  }
  showSex () {
    console.log('这里是父类的方法')
  }
}

class B extends A {
  constructor (name, age, sex) {
    super(sex);
    this.name = name;
    this.age = age;
  }

  showSex () {
    console.log('这里是子类的方法')
  }
}

const b = new B('DBCDOUBLE', 25, '男')
console.log(b);
```

关键：使用extends关键字继承父类的原型属性，调用super来继承父类的实例属性，且保留向父类构造函数传参的优点

优点：简单易用，不用自己来修改原型链来完成继承

    上述代码示例中的super指的就是父类构造函数
    
    子类继承父类的实例属性最终还是通过call或者apply来实现继承的
    
    通过extends方法的调用来修改子类和父类的原型链关系
    
extends做了以下几件事：

    定义了一个function __() {}函数，并把该函数的constructor指向了子类
    
    紧接着，把function __() {} 函数的原型指向了父类的原型
    
    最后再把function () {} 函数的实例赋给了子类函数，就这样子类的实例就能沿着proto.proto获取到父类的原型属性了，这种继承模式俗称圣杯模式

## js继承，绑事件

## 反转二叉树

## vue底层 浏览器渲染过程 https协议 http缓存 promise的知识

## 写了个Promise.all实现

## 问了node模型 webpack底层 jsbridge redux

## 手写eventbus，手写简单中间件，针对你写的代码问各种情况怎么处理

## flex布局）讲一讲flex布局？给子元素设置flex:1是什么含义？flex是哪几个属性的简写？flex-shrink默认值是几？剩余空间的分配规则是怎样的？

## 红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promise实现）

```js
function redToYellowToGreen() {
  function light(color) {
    l.style.background = color
    console.log(color)
  }

  function lightDelay(color, delay) {
    return new Promise((resolve) => {
      let timer = setTimeout(() => {
        light(color)
        resolve(timer)
      }, delay)
    })
  }

  async function oneCycle() {
    const timer1 = await lightDelay('red', 3000)
    const timer2 = await lightDelay('yellow', 2000)
    const timer3 = await lightDelay('green', 1000)
    clearTimeout(timer1)
    clearTimeout(timer2)
    clearTimeout(timer3)
  }

  setInterval(() => {
    oneCycle()
  }, 6000)
}

redToYellowToGreen()
```

阿里

React生命周期及自己的理解

如何配置React-Router

路由的动态加载模块

介绍路由的history

介绍Redux数据流的流程

Redux如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理

多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块

使用过的Redux中间件

如何解决跨域的问题

常见Http请求头

移动端适配1px的问题

介绍flex布局

其他css方式设置垂直居中

居中为什么要使用transform（为什么不使用marginLeft/Top）

使用过webpack里面哪些plugin和loader

webpack里面的插件是怎么实现的

dev-server是怎么跑起来

项目优化

抽取公共文件是怎么配置的

项目中如何处理安全问题

怎么实现this对象的深拷贝

网易

介绍redux，主要解决什么问题
文件上传如何做断点续传
表单可以跨域吗
promise、async有什么区别
搜索请求如何处理（防抖）
搜索请求中文如何请求
介绍观察者模式
介绍中介者模式
观察者和订阅-发布的区别，各自用在哪里
介绍react优化
介绍http2.0
通过什么做到并发请求
http1.1时如何复用tcp连接
介绍service worker
介绍css3中position:sticky
redux请求中间件如何处理并发
介绍Promise，异常捕获
介绍position属性包括CSS3新增
浏览器事件流向
介绍事件代理以及优缺点
React组件中怎么做事件代理
React组件事件代理的原理
介绍this各种情况
前端怎么控制管理路由
使用路由时出现问题如何解决
React怎么做数据的检查和变化
滴滴

react-router怎么实现路由切换
react-router里的<Link>标签和<a>标签有什么区别
<a>标签默认事件禁掉之后做了什么才实现了跳转
React层面的性能优化
整个前端性能提升大致分几类
 import { Button } from 'antd'，打包的时候只打包button，分模块加载，是怎么做到的
 使用import时，webpack对node_modules里的依赖会做什么
JS异步解决方案的发展历程以及优缺点
Http报文的请求会有几个部分
cookie放哪里，cookie能做的事情和存在的价值
cookie和token都存放在header里面，为什么只劫持前者
cookie和session有哪些方面的区别
React中Dom结构发生变化后内部经历了哪些变化
React挂载的时候有3个组件，textComponent、composeComponent、domComponent，区别和关系，Dom结构发生变化时怎么区分data的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理
key主要是解决哪一类的问题，为什么不建议用索引index（重绘）
Redux中异步的请求怎么处理
Redux中间件是什么东西，接受几个参数（两端的柯里化函数）
柯里化函数两端的参数具体是什么东西
中间件是怎么拿到store和action，然后怎么处理
state是怎么注入到组件的，从reducer到组件经历了什么样的过程
koa中response.send、response.rounded、response.json发生了什么事，浏览器为什么能识别到它是一个json结构或是html
koa-bodyparser怎么来解析request
 webpack整个生命周期，loader和plugin有什么区别
 介绍AST（Abstract Syntax Tree）抽象语法树
安卓Activity之间数据是怎么传递的
安卓4.0到6.0过程中WebView对js兼容性的变化
WebView和原生是如何通信
跨域怎么解决，有没有使用过Apache等方案

今日头条

对async、await的理解，内部原理
介绍下Promise，内部实现
 清除浮动
 定位问题（绝对定位、相对定位等）
从输入URL到页面加载全过程
tcp3次握手
tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）
redux的设计思想
接入redux的过程
绑定connect的过程
connect原理
 webpack介绍
== 和 ===的区别，什么情况下用相等==
bind、call、apply的区别
动画的了解
介绍下原型链


CSS
css基本上每个公司也都会问，但是问的不会很深，都是一些常见的问题。
· 盒模型
· 垂直居中方法
· 三栏布局
· 选择器权重计算方式
· 清除浮动的方法
· flex
· 什么是BFC、可以解决哪些问题
· position属性
· 如何实现一个自适应的正方形
· 如何用css实现一个三角形
手写题
手写题每个公司都会有，范围也比较固定，如果之前好好准备的话，应该没什么问题。
· 防抖和节流
· 深拷贝
· 数组去重、数组乱序
· 手写call、apply、bind
· 继承（ES5/ES6）
· sleep函数
· 实现promise
· 实现promise.all
· 实现promise.retry
· 将一个同步callback包装成promise形式
· 写一个函数，可以控制最大并发数
· jsonp的实现
· eventEmitter(emit,on,off,once)
· 实现instanceof
· 实现new
· 实现数组flat、filter等方法
· lazyMan
· 函数currying

ES6
现在基本上都会使用ES6开发。ES6也成为了一个面试必考点。一般面试官都会问用过ES6的哪些新特性，再针对你所回答的进行深入的提问。
· let、const、var区别
· 箭头函数与普通函数的区别
· 变量的结构赋值
· promise、async await、Generator的区别
· ES6的继承与ES5相比有什么不同
· js模块化（commonjs/AMD/CMD/ES6）
浏览器相关知识
浏览器相关知识几乎是每个公司都会问到的考点，里面涉及的东西也比较多。其中缓存、http2、跨域必问。
· 从输入URL到呈现页面过程
· 强缓存、协商缓存、CDN缓存
· HTTP2
· HTTP状态码
· 三次握手与四次挥手
· 跨域（JSONP/CORS）
· 跨域时如何处理cookie
· 垃圾回收机制
web安全
一般我都会从xss和csrf说起。
· https
· 什么是xss，如何预防
· 什么是csrf，如何预防
· 为什么会造成csrf攻击

事件循环
事件循环绝对是一个必考题。其中涉及到宏任务、微任务、UI渲染等的执行顺序，浏览器端的必须要掌握，node端的有精力的最好也能掌握。
框架（vue）
因为我一直用的都是vue框架，所以问的也都是跟vue相关的。vue中的高频题也不外乎双向绑定、虚拟dom、diff算法这些。
· watch与computed的区别
· vue生命周期及对应的行为
· vue父子组件生命周期执行顺序
· 组件间通讯方法
· 如何实现一个指令
· vue.nextTick实现原理
· diff算法
· 如何做到的双向绑定
· 虚拟dom为什么快
· 如何设计一个组件
webpack
webpack也基本上成了必考的内容，一般会问是否配置过webpack、做过哪些优化之类的。
· 用过哪些loader和plugin
· loader的执行顺序为什么是后写的先执行
· webpack配置优化
· webpack打包优化（happypack、dll）
· plugin与loader的区别
· webpack执行的过程
· 如何编写一个loader、plugin
· tree-shaking作用，如何才能生效
性能优化
· 首屏加载如何优化
· 一个网页从请求到呈现花了很长时间，如何排查
