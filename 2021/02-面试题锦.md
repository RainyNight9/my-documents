# 面试题锦

## 1、JS事件循环

* JS是单线程语言：顺序执行

* 任务队列

```js
let data = [];
$.ajax({
  url:www.javascript.com,
  data:data,
  success:() => {
    console.log('发送成功!');
  }
})
console.log('代码执行结束');
```

* setTimeout

```js
setTimeout(() => {
  task()
},3000)

sleep(10000) // sleep为一个同步任务，10000为执行时间
```

>注：即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

* Promise

Promise 新建后就会立即执行。

* 宏任务和微任务

  * macro-task(宏任务)：整体代码script，setTimeout，setInterval
  * micro-task(微任务)：Promise

>注：在事件循环中，永远先执行可执行的微任务

```js
setTimeout(function(){
  console.log('1')
});

new Promise(function(resolve){
  console.log('2');
  for(var i = 0; i < 10000; i++){
    i == 99 && resolve();
  }
}).then(function(){
  console.log('3')
});

console.log('4');
```

```js
console.log('1');

setTimeout(function () {
  console.log('2');
  new Promise(function (resolve) {
    console.log('3');
    resolve();
  }).then(function () {
    console.log('4')
  })
})

new Promise(function (resolve) {
  console.log('5');
  resolve();
}).then(function () {
  console.log('6')
})

setTimeout(function () {
  console.log('7');
  new Promise(function (resolve) {
    console.log('8');
    resolve();
  }).then(function () {
    console.log('9')
  })
})
```

## 2、函数柯里化

* 什么事函数柯里化？

```js
function multiply(a, b, c) {
  return a * b * c;
}
multiply(1, 2, 3); // 6

// 柯里化后：
function multiply(a) {
  return (b) => {
    return (c) => {
      return a * b * c
    }
  }
}
multiply(1)(2)(3) // 6
```

通过把一个多参函数转换成一系列嵌套的函数，每个函数依次接受一个参数，这就是函数柯里化。

```js
let _fn = curry(function (a, b, c, d, e) {
  console.log(a + b + c + d + e)
});
console.log(fn);

_fn(1, 2, 3, 4, 5);  //15
_fn(1)(2)(3, 4, 5);  //15
_fn(1, 2)(3, 4)(5);  //15
_fn(1)(2)(3)(4)(5);  //15
function curry(fn, len = fn.length) {
  return _curry.call(this, fn, len)
}


function _curry(fn, len, ...args) {
  return function (...params) {
    console.log(params);
    let _args = [...args, ...params];
    console.log(_args);
    if (_args.length >= len) {
      return fn.apply(this, _args);
    } else {
      return _curry.call(this, fn, len, ..._args)
    }
  }
}
```

## 3、add(1,2)(3)(4,5) // 15 (字节原题)

要求如下：

```js
const add3  = add(0, 1)(2) // add3的功能是对传入的数值加3并返回
console.log(  add3(2) + 0  ) // log出5
const add8  = add3(1)(2)(2) // add8由add3的持续调用得到
const add8p = add3(5) // 另一种方式得到add8，注意两个add8不是同一个函数，起名add8p
const add9  = add8(1) // 由add8再传入得到add9函数
console.log(  add9(1) + 3  ) // log出13
console.log(  add8(1) + 3  ) // log出12
/*
注意以上代码中的add，add3，add8，add8p，add9都是不同的函数，且每个函数要加的数是不一样的。
*/
```

答案如下：

```js
function add(...args) {

  // 将参数绑定到add上
  // 此时f其实还是add函数，但已经固定了一些参数，所以并不是原来的add函数
  // 用bind返回新函数以保证满足**柯里化保留参数**的特性
  var f = add.bind(null/*this不用绑定*/, ...args) 

  // 重新实现这个bound add函数的toString方法
  // f参与运算应该被当成args的和，与f自己再接收的参数无关
  // 考虑到lazy的特性，还是需要时再计算，但又没了缓存，每次用都会重新计算
  // 如果有需要，可以改成有缓存的版本
  f.toString = () => {
    return args.reduce((a, b) => a + b, 0)
  }

  return f
}

// 考虑到add可能直接被用于运算中，可以加上这句
add.toString = () => 0
```

本题解来自知乎大佬[谢然](https://zhuanlan.zhihu.com/p/296852112)

## 4、React Hooks 模拟出几个常用的生命周期 （字节原题）

```js
useEffect(() => {
  // 组件挂载后执行事件绑定
  console.log('on')
  addEventListener()

  // 组件 update 时会执行事件解绑
  return () => {
    console.log('off')
    removeEventListener()
  }
}, [source]);


// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):
// --- DidMount ---
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- DidUpdate ---
// 'off'
// 'on'
// --- WillUnmount --- 
// 'off'
```

通过第二个参数，我们便可模拟出几个常用的生命周期:

* componentDidMount: 传入[]时，就只会在初始化时调用一次；

```js
const useMount = (fn) => useEffect(fn, [])
```

* componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次；

```js
const useUnmount = (fn) => useEffect(() => fn, [])
```

* mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；

```js
const useMounted = () => {
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    !mounted && setMounted(true);
    return () => setMounted(false);
  }, []);
  return mounted;
}
```

* componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；

```js
const mounted = useMounted() 
useEffect(() => {
  mounted && fn()
})
```

另外可参考：

1、[React Hooks 介绍及与传统 class 组件的生命周期函数对比
](https://blog.csdn.net/u014607184/article/details/109744910)

2、[使用React Hooks模拟生命周期
](https://juejin.cn/post/6844903921442373639)

## 5、sass与less区别

[Sass和less的区别是什么？用哪个好](https://www.cnblogs.com/pink-chen/p/10727915.html)

## 6、canvas和svg区别

***SVG***

* SVG 是一种使用 XML 描述 2D 图形的语言。

* SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。

* 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。

***Canvas***

* Canvas 通过 JavaScript 来绘制 2D 图形。

* Canvas 是逐像素进行渲染的。

* 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。

***Canvas 与 SVG 的比较***

Canvas:

* 依赖分辨率
* 不支持事件处理器
* 弱的文本渲染能力
* 能够以 .png 或 .jpg 格式保存结果图像
* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

SVG:

* 不依赖分辨率
* 支持事件处理器
* 最适合带有大型渲染区域的应用程序（比如谷歌地图）
* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
* 不适合游戏应用

## 7、了解可视化框架

***1、D3.js***

D3 的全称是（Data-Driven Documents）。D3 .js是一个JavaScript库（是一个被数据驱动的文档），用于在浏览器中创建交互式可视化。

D3.js库允许我们在数据集的上下文中操作网页的元素.这些元素可以是HTML，SVG，或画布元素，可以根据数据集的内容进行引入，删除或编辑.它是一个用于操作DOM对象的库. D3.js可以成为数据探索的宝贵帮助，它可以让您控制数据的表示，并允许您添加交互性.

***2、highcharts***

Highcharts 是一个用纯JavaScript编写的一个图表库， 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表,HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。

***3、echarts***

ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

ECharts 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。

***4、兼容性***

Highcharts 兼容 IE6 及以上的所有主流浏览器，完美支持移动端缩放、手势操作。

Echarts 兼容 IE6 及以上的所有主流浏览器，同样支持移动端的缩放和手势操作。

D3 兼容IE9 及以上的所有主流浏览器，对于移动端的兼容性也同上。

也就是说，这三个插件都兼容IE9及以上的所有主流浏览器，但如果开发需求中包括IE7/IE8，那么就只能选择Highcharts或者Echarts了。

***5、是否免费/开源***

Highcharts 非商业免费，商业需授权，代码开源。

Echarts 完全免费，代码开源。

D3 完全免费，代码开源。

***6、难度***

Highcharts 基于SVG，方便自己定制，但图表类型有限。

Echarts 基于Canvas，适用于数据量比较大的情况。

D3.v3 基于SVG，方便自己定制；D3.v4支持Canvas+SVG，如果计算比较密集，也可以选择用Canvas。除此之外，D3图表类型非常丰富，几乎可以满足所有开发需求，但代码相对于以上两个插件来说，会稍微难一点。

***7、性能优化***

在同一图层内，可以容纳大量数据绘制，性能较好，但不支持每个对象的变化

不同图层，大量数据绘制效果较差，但支持每个对象的变化

最差的情况，每次删除所有图层，再创建图层，重新绘制

***8、正确理解Repaint和Reflow***

Repaint 和 Reflow 也就是重绘和重排，Repaint(重绘)就是在一个元素的外观被改变，但没有改变布局(宽高)的情况下发生，如改变visibility、outline、背景色等等。

Reflow(重排)就是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证DOM树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如：改变窗囗大小、改变文字大小、内容的改变、浏览器窗口变化，style属性的改变等等。如果Reflow的过于频繁，CPU使用率就会噌噌的往上涨，所以前端也就有必要知道 Repaint 和 Reflow的知识。

上面提到通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow，所以最好通过设置class的方式；有动画效果的元素，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局；如果功能需求上不能设置position为fixed或absolute，那么就权衡速度的平滑性。

总之，因为 Reflow 有时确实不可避免，所以只能尽可能限制Reflow的影响范围。

## 8、Grunt，Gulp、Webpack、Rollup、Parcel 区别

>四款前端主流的打包工具：grunt， gulp，webpack， rollup，以发布时间为顺序。

***Grunt：***

最老牌的打包工具，它运用配置的思想来写打包脚本，一切皆配置，所以会出现比较多的配置项，诸如option,src,dest等等。而且不同的插件可能会有自己扩展字段，认知成本高，运用的时候需要明白各种插件的配置规则。

***Gulp：***

用代码方式来写打包脚本，并且代码采用流式的写法，只抽象出了gulp.src, gulp.pipe, gulp.dest, gulp.watch 接口，运用相当简单。更易于学习和使用，使用gulp的代码量能比grunt少一半左右。

***webpack:***

是模块化管理工具和打包工具。通过 loader 的转换，任何形式的资源都可以视作模块，比如 Commonjs 模块、AMD 模块、ES6 模块、css、图片等。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。它定位是模块打包器，而 Gulp/Grunt 属于构建工具。Webpack 可以代替 Gulp/Grunt 的一些功能，但不是一个职能的工具，可以配合使用。

***Rollup：***

下一代 ES6 模块化工具，最大的亮点是利用 ES6 模块设计，利用 tree-shaking生成更简洁、更简单的代码。一般而言，对于应用使用 Webpack，对于类库使用 Rollup；需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 Commonjs 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup。

***Parcel***

几乎零配置，而且打包入口也不仅仅只是JS，另外其打包速度也要比Webpack快。

==使用总结：==

***Grunt：***

MPA，老牌打包工具，基于文件为媒介（运行慢，零散的脚本文件一当多起来就受到影响

***Gulp：***

MPA，易学，基于 nodejs 的 steam 流打包

***Webpack：***

SPA，目前最强大的打包工具，但是过于臃肿，如何单纯打包js不推荐

***Roleup：***

MPA，tree-shaking特性（针对es6，按需打包，多余的不要，目前（2018，vuex,react主流使用）

***Parcel***

虽然Parcel相比Webpack似乎具有更多优势，但它毕竟还不够成熟，没有Webpack庞大的社区，一旦遇到问题很难在网上快速找到相应解决办法。

## 9、JSBridge实现原理

## 10、链表

## 11、字符串

## 12、promise

## 13、截流和防抖

## 14、

## 15、二叉树遍历
