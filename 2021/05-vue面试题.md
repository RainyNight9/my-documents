# vue

## 1、v-if和v-for哪个优先级高

源码中找答案compiler/codegen/index.js

    1、v-for优先于v-if 被解析

    2、如果同时出现，每次渲染都会先执行循环在判断条件，无论如何，循环都不可避免，浪费了性能

    3、要避免出现这种情况，可以在外层嵌套 template，在这一层加v-if，然后内部进行v-for循环

    4、如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项

## 2、Vue组件data选项为什么必须是个函数而Vue的根实例则没有此限制

源码中找答案：src\core\instance\state.js - initData()

>函数每次执行都会返回全新data对象实例

    1、vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的

    2、采用函数形式定义，在initData() 时会将其作为工厂函数返回全新data实例，有效规避多实例之间状态污染问题

    3、vue根实例创建过程中，则不存在该限制，也是因为根实例只有一个，不需要担心这种情况。

## 3、你知道vue中key的作用和工作原理吗？说说你对它的理解

源码中找答案：src\core\vdom\patch.js - updateChildren()

    1、key 的作用主要就是为了高效的更新DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁的更新相同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。

    2、如果不设置key，还可能在列表更新时引发一些隐藏bug

    3、vue中在使用相同标签名元素的过度切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue 只会替换其内部属性而不会触发过度效果。

## 4、你怎么理解vue中的diff算法？

源码分析1：必要性，lifecycle.js - mountComponent()

组件中可能存在很多个data中的key使用

源码分析2：执行方式，patch.js - patchVnode()

patchVnode是diff发生的地方，整体策略：深度优先，同层比较

源码分析3：高效性，patch.js - updateChildren()

    1、diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM做对比，将变化的地方更新在真实DOM上，另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)

    2、vue2中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。

    3、vue中diff执行的时刻是组件实例执行更新函数时，它会比对上一次的渲染结果oldVnode和新渲染结果newVnode，此过程称之为patch

    4、diff过程整体遵循深度优先、同层比较的策略。两个节点之间比较会根据它们是否拥有字节点或者文本节点做不同操作。比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点，借助key通常可以非常精确的找到相同节点，因此整个patch过程非常高效。

## 5、谈一谈对vue组件化的理解

源码分析1：组件定义，src\core\global-api\assets.js

>vue-loader会编译template为render函数，最终导出的依然是组件配置对象。

源码分析2：组件化优点，lifecycle.js - mountComponent()

>组件、Watcher、渲染函数和更新函数之间的关系

源码分析3：组件化实现，构造函数，src\core\global-api\extend.js 实例化及挂载，src\core\vdom\patch.js - createElm()

    1、组件是独立和可复用的代码组织单元，组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用。

    2、组件化开发能大幅度提高应用开发效率，测试性，复用性等。

    3、组件使用按分类有：页面组件、业务组件、通用组件。

    4、vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，他们基于VueComponent，扩展于vue

    5、vue中常见的组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等

    6、合理的划分组件，有助于提升应用性能

    7、组件应该是高内聚，低耦合的。

    8、遵循单向数据流的原则

## 6、谈一谈对vue的设计原则的理解

    1、渐进式JS框架

        * vue被设计为可以自底向上逐层应用。
        * vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。
        * 当与现代化工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动。

    2、易用性

        * vue提供数据响应式、声明式模版语法和基于配置的组件系统等核心特性
        * 使我们只关注应用的核心业务即可，只会写js，css，html就能轻松过编写vue应用

    3、灵活性

        * 渐进式框架最大的优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能
        * 随着应用不断扩大，才可能逐渐引入路由，状态管理，等工具和库，不管是应用体积hi啊好死学习难度都是一个逐渐增加的平和曲线

    4、高效性

        * 超快的虚拟DOM 和diff算法使我们的应用拥有极佳的性能表现
        * 追求高效的过程还在继续，vue3中引入proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效

## 7、谈谈你对MVC、MVP和MVVM的理解

    1、这三个都是框架模式，它们设计的目标都是解决Model和View的耦合问题

    2、MVC模式出现比较早，主要应用在后端，在前端领域的早期也有应用，如Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题

    3、MVP模式是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层过于臃肿会导致维护问题

    4、MVVM模式在前端领域有广泛的应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。

## 8、你了解哪些vue性能优化的方法

    1、路由懒加载

    2、keep-alive缓存页面

    3、v-show复用DOM

    4、v-for遍历避免同时使用v-if

    5、长列表性能优化

        * 纯数据，非响应式的可以 使用 object.freeze 冻结
        * 大数据长列表，可采用虚拟滚动，只渲染少部分内容 （vue-virtual-scroller、vue-virtual-scroll-list）

    6、事件的销毁

    7、图片的懒加载 （vue-lazyload）

    8、第三方插件按需引入

    9、无状态组件标记为函数组件 functional

    10、子组件分割

    11、变量本地化

    12、SSR （SEO、首屏渲染）

## 9、vue3新特性

    1、更快

        * 虚拟DOM重写（编译时提示减少运行时开销，使用更有效的代码创建虚拟节点。组件快速路径+单个调用+子节点类型检查。跳过不必要的条件分支。js引擎更容易优化）
        * 优化slots的生成（vue3中可以单独重新渲染父级和子级。确保实例正确的跟踪依赖关系。避免不必要的父子组件重新渲染）
        * 静态树提升（内存换时间，）
        * 静态属性提升 
        * 基于Proxy的响应式系统

    2、更小

        * 通过摇树优化核心库体积

    3、更容易维护

        * TS+模块化

    4、更加友好

        * 跨平台：编译器核心和运行时核心与平台无关

    5、更容易使用

        * 改进ts支持，编译器提供更好的类型检查和错误及警告
        * 更好的调试支持
        * 独立的响应式模块
        * Composition API

## 10、vuex使用及理解

    1、

    2、

    3、

    4、

    5、

## 11、vue中组件之间的通信方式？

    1、父子组件通信
        * props
        * $emit/$on
        * $children/$parent
        * $attrs/$listeners
        * ref
    2、兄弟组件
        * $parent
        * $root
        * eventbus
        * vuex
    3、跨层级关系
        * eventbus
        * vuex
        * provide/inject

## 12、vue-router中如何保护指定路由的安全？

    1、

## 13、你知道nextTick吗？它是干什么的？实现原理是什么？

    1、

## 14、谈一谈你对vue响应式原理的理解？

