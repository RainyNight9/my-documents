# 复盘

## sx

面试题：

1、水平垂直居中

    1、定宽高
      一、绝对定位 + 负margin值
      二、绝对定位 + transform
      三、绝对定位 + left/right/bottom/top + margin
      四、flex布局
      五、grid布局 + margin: auto;
      六、table-cell + vertical-align + inline-block/margin: auto
    2、不定宽高
      一、绝对定位 + transform
      二、table-cell + vertical-align + inline-block
      三、flex布局
      四、flex变异布局 + margin: auto;
      五、grid + flex布局（align-self: center;justify-self: center;）
      六、gird + margin布局（margin: auto;）
      七、writing-mode属性布局

一、内联元素居中布局

  水平居中

    行内元素可设置：text-align: center;
    flex布局设置父元素：display: flex; justify-content: center;

  垂直居中

    单行文本父元素确认高度：height === line-height
    多行文本父元素确认高度：display: table-cell; vertical-align: middle;

二、块级元素居中布局

    水平居中
      定宽: margin: 0 auto;
      不定宽： 参考上诉例子中不定宽高例子。

    垂直居中
      position: absolute设置left、top、margin-left、margin-to(定高)；
      position: fixed设置margin: auto(定高)；
      display: table-cell；
      transform: translate(x, y)；
      flex(不定高，不定宽)；
      grid(不定高，不定宽)，兼容性相对比较差；

[答案](https://juejin.cn/post/6844903982960214029)

2、css动画，css动画和js动画区别

    transition: 过渡动画
      transition-property: 属性
      transition-duration: 间隔
      transition-timing-function: 曲线
      transition-delay: 延迟
      常用钩子: transitionend

    animation / keyframes
      animation-name: 动画名称，对应@keyframes
      animation-duration: 间隔
      animation-timing-function: 曲线
      animation-delay: 延迟
      animation-iteration-count: 次数
        infinite: 循环动画
      animation-direction: 方向
        alternate: 反向播放
      animation-fill-mode: 静止模式
        forwards: 停止时，保留最后一帧
        backwards: 停止时，回到第一帧
        both: 同时运用 forwards / backwards
      常用钩子: animationend

    动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现
      translate
      scale
      rotate
      skew
      opacity
      color

3、定位区别 static(默认) relative(自身) absolute(窗口，随滚动，上边不是static的) fixed（浏览器视窗，不随滚动） sticky
4、继承
    
    一、原型链继承 prototype 
      无法实现多继承（一个子类继承成多个父类）
      创建子类实例的时候，无法向父类构造函数传参
      有子类实例共享父类引用属性的问题（因为子类的原型指向的是父类的一个实例，假如父类的私有属性有一个是数组(引用类型)，那么任一子类都可以操作这个数组，从而导致其他子类使用的这个数组也会发生变化）
    二、借用父类构造函数继承 call或者apply
      解决了原型链继承的缺点
      每次创建子类实例时，都要调用一次父类构造函数，影响性能
      只继承父类的实例属性(私有属性)，没有继承父类的原型属性
    三、组合式继承(原型链继承 + 借用构造函数继承)
      解决了上两种的缺点
    四、ES6的class/extends继承
      使用extends关键字继承父类的原型属性，调用super来继承父类的实例属性，且保留向父类构造函数传参的优点

5、闭包及场景

    闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

    作用:读取函数内部的函数,始终保持在内存中
    优点:变量长期保持在内存中,不会清除,避免全局污染
    缺点:增大内存使用,导致内存泄漏
    场景：自执行函数。返回一个函数（防抖、节流、）。在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。作为函数参数传递的形式。

6、缓存

    缓存策略: 可分为 强缓存 和 协商缓存

      * Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires

        Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）

        Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）
        Cache-Control 的值：no-cache、no-store、max-age、max-stale、min-fresh、no-transform、only-if-cached、must-revalidate、public、private、proxy-revalidate......

      * 当缓存已经过期时，使用协商缓存

        唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
        最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)

          如果一致，则直接返回 304 通知浏览器使用缓存
          如不一致，则服务端返回新的资源

      * Last-Modified 缺点：

        周期性修改，但内容未变时，会导致缓存失效
        最小粒度只到 s， s 以内的改动无法检测到

      * Etag 的优先级高于 Last-Modified

7、数据类型

    boolean null undefined number string symbol BigInt

    引用数据类型（Object）：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象。

    1、基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；

    2、引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。

8、typeof instanceof Object.prototype.toString

    1、instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；

    2、而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。

    typeof null        // 'object'
    typeof console.log // 'function'

    let str = 'Covid-19'
    str instanceof String   // false

```js
function myInstanceof(left, right) {
  // 这里先用typeof来判断基础数据类型，如果是，直接返回false
  if(typeof left !== 'object' || left === null) return false;
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  let proto = Object.getPrototypeOf(left);
  while(true) {                  //循环往下寻找，直到找到相同的原型对象
    if(proto === null) return false;
    if(proto === right.prototype) return true;//找到相同原型对象，返回true
    proto = Object.getPrototypeof(proto);
  }
}
// 验证一下自己实现的myInstanceof是否OK
console.log(myInstanceof(new Number(123), Number));    // true
console.log(myInstanceof(123, Number));                // false   
```

9、事件循环

    事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

      微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
      宏任务 macrotask(task): setTimout / script / IO / UI Rendering

10、vue vs react 生命周期 数据响应 setState（事务）使用场景区别对比

    * setState：事务 (Transaction):

      是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；

    * setState: React 中用于修改状态，更新视图。它具有以下特点:

      异步与同步: setState并不是单纯的异步或同步，这其实与调用时的环境相关:

        在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是"异步"的；

          原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；

            在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；
            在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；

          问题: 无法在setState后马上从this.state上获取更新后的值。
          
          解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；

        在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值；

          原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；

      批量更新: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；

      函数式: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；

        使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；

      注意事项:

        setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；
        当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法:

          将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；
          在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；

11、原型

    * 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。

    * 构造函数: 可以通过new来 新建一个对象 的函数。

    * 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。

```js
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的
// instance.hasOwnProperty('constructor') === false 
实例.constructor === 构造函数
```

12、跨域

* JSONP: 利用<script>标签不受跨域限制的特点，缺点是只能支持 get 请求

```js
function jsonp(url, jsonpCallback, success) {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
```
* 设置 CORS: Access-Control-Allow-Origin：*
* postMessage
* nginx
* webpack 本地代理

13、内存泄漏

    意外的全局变量: 无法被回收
    定时器: 未被正确关闭，导致所引用的外部变量无法被释放
    事件监听: 没有正确销毁 (低版本浏览器可能出现)
    闭包: 会导致父级中的变量无法被释放
    dom 引用: dom 元素被删除时，内存中的引用未被正确清空

**可用 chrome 中的 timeline（Performance） 进行内存标记，可视化查看内存的变化情况，找出异常点。**

14、性能优化

    1. 编码优化

        * 数据读取:

          通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；
          对象嵌套越深，读取值也越慢；
          
          最佳实践:
            尽量在局部作用域中进行 变量缓存；
            避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护；

        * 循环: 循环通常是编码性能的关键点；

          代码的性能问题会再循环中被指数倍放大；
          
          最佳实践:
            尽可能 减少循环次数；
              减少遍历的数据量；
              完成目的后马上结束循环；
            避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
            js 中使用 倒序循环 会略微提升性能；
            尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；

        * 条件流程性能: Map / Object > switch > if-else

        * 减少 cookie 体积: 能有效减少每次请求的体积和响应时间；

          去除不必要的 cookie；
          压缩 cookie 大小；
          设置 domain 与 过期时间

        * dom 优化:

          减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
          减少重绘与回流:

            多次操作合并为一次；
            减少对计算属性的访问；

              例如 offsetTop， getComputedStyle 等
              因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；

            大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
            使用DocumentFragment / cloneNode / replaceChild进行操作；

          使用事件委托，避免大量的事件绑定；

        * css 优化:

          层级扁平，避免过于多层级的选择器嵌套；
          特定的选择器 好过一层一层查找:  .xxx-child-text{} 优于 .xxx .child .text{}
          减少使用通配符与属性选择器；
          减少不必要的多余属性；
          使用 动画属性 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
          使用 <link> 替代原生 @import；

        * html 优化:

          减少 dom 数量，避免不必要的节点或嵌套；
          避免<img src="" />空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

            IE 向页面所在的目录发送请求；
            Safari、Chrome、Firefox 向页面本身发送请求；
            Opera 不执行任何操作。

          图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；
          语义化标签 有利于 SEO 与浏览器的解析时间；
          减少使用 table 进行布局，避免使用<br />与<hr />；

    2. 页面基础优化

      * 引入位置: css 文件<head>中引入， js 文件<body>底部引入；

        影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；

      * 减少请求 (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
      * 减少文件体积:

        删除多余代码:
          tree-shaking
          UglifyJs
          code-spliting

        混淆 / 压缩代码，开启 gzip 压缩；
        多份编译文件按条件引入:
          针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
          可以利用<script type="module"> / <script type="module">进行条件引入用

        动态 polyfill，只针对不支持的浏览器引入 polyfill；

      * 图片优化:

        根据业务场景，与UI探讨选择 合适质量，合适尺寸；
        根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
        小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；
        合适场景下，使用 iconfont 或者 svg；

      * 使用缓存:

        浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；
        CDN缓存: 静态文件合理使用 CDN 缓存技术；

          HTML 放于自己的服务器上；
          打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
          由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；

        服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
        数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

    3. 首屏渲染优化

      * css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；
      * 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；
      * 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；
      * 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑；

        控制字体包的加载时机；
        如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；

      * 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存；
      * 分清轻重缓急:

        重要的元素优先渲染；
        视窗内的元素优先渲染；

      * 服务端渲染(SSR):

        减少首屏需要的数据量，剔除冗余数据和请求；
        控制好缓存，对数据/页面进行合理的缓存；
        页面的请求使用流的形式进行传递；

      * 优化用户感知:

        利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
        尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
        动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
        js 执行时间避免超过 100ms，超过的话就需要做:

          寻找可 缓存 的点；
          任务的 分割异步 或 web worker 执行；

15、html5、css3

## blm

1、性能优化，谷歌调试工具

    Performance
    lighthouse

2、react、vue

3、node、reatful api

4、es6+ promise

5、脚手架
6、B/S架构工作原理

    第一层表现层：主要完成用户和后台的交互及最终查询结果的输出功能。
    第二层逻辑层：主要是利用服务器完成客户端的应用逻辑功能。
    第三层数据层：主要是接受客户端请求后独立进行各种运算。

    B/S架构采取浏览器请求，服务器响应的工作模式。

7、居中布局
8、flex与margin区别
9、float与position区别

    absolute/fixed和float对比
    类似：元素都会从文档流删除，但是依旧会影响布局;都会生成一个块级框，无论原来是不是块级元素。
    区别：float的包含块是最近的块级祖先元素。

    visibility:hidden和display:none的区别：
    visibility:hidden设置元素不可见，但是元素依旧会影响布局，只是元素部分呈现为空白;
    display:none元素不显示并且从文档流中删除，对文档布局没有任何影响。

10、transform有哪些属性，使用场景

    transform的属性值主要包括旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix

      1、transform:rotate(30deg),2D旋转，正值为顺时针旋转，负值为逆时针旋转，默认旋转基点是中心点，也可以通过transform-origin（X,Y）改变基点。
      2、transform:skew(30deg,10deg),注意，这里的X轴和Y轴与我们平时认为的坐标系的XY轴正好相反；且X轴正值是逆时针变形，而Y轴正值是顺时针变形。基点默认为中心点。另外还有skewX、skewY，分别用来设置单一方向上的扭曲。可以通过transform-origin（X,Y）改变基点
      3、transform：scale（2,1.5），表示在水平方向（X轴）缩放2倍，在垂直方向（Y轴）缩放1.5倍。基本默认为中心点。这里的X、Y轴指的是像坐标系一样的X、Y轴，与transform:skew（X,Y）的X
      Y轴不同。 另外同样有scaleX(<number>)、scaleY(<number>)用来分别设置单一方向上的缩放。可以通过transform-origin（X,Y）改变基点。
      4、transform：translate（100px，20px），表示在水平方向上移动100px；在垂直方向上移动20px，比较好理解，另外也同样有translateX、translateY值分别设置单一方向上的位移，可以通过transform-origin（X,Y）改变基点

11、继承
12、vue数据绑定、key的作用、虚拟dom、diff算法
13、怎么管理团队

    Leader 的视野和高度
      团队 Leader 除了前端视角外，应多了解后端、客户端、产品、运营等多方面知识面扩展自己的思维，并多与横向团队的 Leader 学习交流。让自己多些工程师的行业视野与全局视角。
    为下边的员工考虑
      看在团队实现阶段目标后给大家争取多少福利。加多少工资，跳槽后能拿多少钱，是否实现自身价值。简单粗暴点的标准是看是否有公司从你这抢人作为判断依据，让你的团队变得牛逼。
    公司/部门影响力
      业界影响力，公司内部影响力
    团队脾气，性格（脾性、心态、经验、甚至人品昔昔相关）
      团队内不合群，负能量，过分个性...多交流沟通，需要自己以身作则践行团队文化。
    执行力
      团队驱动力

14、html语义化

    根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

    为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
    用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
    有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
    方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
    便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
  
15、数据类型
16、类型判断
17、this指向
18、set、map

  Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构

19、parmise.all 使用场景


20、vue生命周期，主要挂载和请求时机
21、watch和computed
22、nextTick
23、vuex 为什么不是响应式的

    原来获取 vuex 中的值一定要用计算属性获取

24、webpack的作用

    * 预编译
    * 模块打包工具, 提供了 打包功能 和一套 文件处理机制,高度的可拓展性
    * 模块机制
    * 文件编译

25、loader原理

    * 不同格式文件转换器
    * 对 Webpack 传入的字符串进行按需修改
    * 需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串
    * 链式传递，按照配置时相反的顺序链式执行；
    * 基于 Node 环境，拥有 较高权限，比如文件的增删查改；
    * 可同步也可异步；
    * 单一原则: 每个 Loader 只做一件事；
    * 链式调用: Webpack 会按顺序链式调用每个 Loader；
      * 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

26、vue.$set vue.$delete

准备了上边那么多，完了就问我四个问题：

### blm 面试题

1、flex 原理

    * 弹性布局
    * 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
    * 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）
    * flex-direction属性决定主轴的方向
    * flex-wrap 如果一条轴线排不下，如何换行
    * flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
    * justify-content属性定义了项目在主轴上的对齐方式。
    * align-items属性定义项目在交叉轴上如何对齐。
    * align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

    * order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
    * flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
    * flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
    * flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
    * flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
    * align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

2、移动端适配原理

```js
(function (doc, win) {
  var docEl = doc.documentElement,
    resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    recalc = function () {
      var clientWidth = docEl.clientWidth;
      if (clientWidth >= 750) {
        clientWidth = 750;
      };
      if (clientWidth <= 320) {
        clientWidth = 320;
      }
      if (!clientWidth) return;
      docEl.style.fontSize = 100 * (clientWidth / 750) + 'px';
    };
  if (!doc.addEventListener) return;
  win.addEventListener(resizeEvt, recalc, false);
  doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);
```

3、this

    * this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。
    * this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
    * 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。
    * 这个记录会包含函数在哪里被调用（调用栈），函数的调用方式、传入的参数等信息。
    * this就是这个记录的一个属性，会在函数执行的过程中用到。
    * this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

判断一个运行中函数的this绑定，就需要找到函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断this的绑定对象：

    1、由new调用？绑定到新创建的对象。
    2、由call或者apply（或者bind）调用？绑定到指定的对象。
    3、由上下文对象调用？绑定到那个上下文对象。
    4、默认：严格模式下绑定到undefined，否则绑定到全局对象。

自己总结（可能有偏差）：

    1、事件调用环境：谁触发事件，函数里边的this 指向的就是谁
    
    2、普通函数里边的this 最终指向的是调用它的对象
    
    3、函数被多层对象所包含，如果函数被最外层对象调用，this指向的也只是它上一级的对象
    
    4、构造函数中的this指向的是实例化对象，注意return
    
    5、箭头函数本身是没有this 和 arguments

this有四种情况

    1、当在函数调用的时候指向widow
    
    2、当方法调用的时候指向调用对象
    
    3、当用apply和call上下文调用的时候指向传入的第一个参数 
    
    4、构造函数调用指向实例对象 

JS中this关键字， 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。全局函数调用时，this指向全局函数； 应该是指向调用全局函数的对象。

4、防抖节流，也手写

    就是指触发事件后在n秒内函数只能执行一次，如果n秒内又触发了事件，则会重新计算函数执行时间。
    
    就是指连续触发事件但是在一段时间中只执行一次函数，控制函数被触发的频率。

## ok

1、性能优化
    编码优化
      数据读取优化（变量缓存，数据扁平化）
      循环优化（减少循环，避免循环中大量计算，倒叙，避免for-in）
      条件流程（Map/Object > switch > if-else）
      减少cookie体积（去除多余的，压缩，设置domain和过期时间）
      dom优化（减少访问dom，减少重绘和回流，使用事件委托）
      css优化（层级扁平，特定选择器，减少使用通配符，减少不必要的多余属性，css动画）
      html优化（减少dom数量，避免空标签，图片指定宽高，脱离文档流，语义化，减少table布局）
    页面基础优化
      ccs、js引入位置
      减少请求
      减少文件体积
        删除多余代码（tree-shaking、uglify.js、code-spliting）
        压缩代码 （gzip）
        多份编译文件按条件引入
        动态poyfill
      图片优化
        合适大小尺寸
        合适格式
        雪碧图，base64
        iconfont或者svg
      缓存
        浏览器缓存
        cdn缓存
        服务器缓存
        数据缓存
    首屏加载优化
      css/js精简分割
      非关键异步加载和懒加载
      dns-prefetch/preconnect/prefetch/preload
      控制web字体库
      合理 浏览器缓存
      分轻重缓急
      服务端渲染
      优化用户感知
        过度效果，动画
        骨架平
        动画顺畅，不顺的去掉
2、DOM
    Document Object Model
    document
3、BOM
    Browser Object Model
    浏览器对象模型 window
4、AJAX
    Asynchronous Javascript And XML
    let xhr = new XMLHttpRequest()
    xhr.onreadystatechange = ()=>{
      if(xhr.readyState == 4) {
        if(xhr.status == 200 || xhr.status == 0) {
            document.write(xhr.responseText); // 将返回结果以字符串形式输出
        }
      }
    }
    xhr.open(method,URL,flag,name,password)
    xhr.send(data);
5、Restful
6、json
7、vue vs react
    设计思想
      vue 渐进式框架 双向绑定
      react 主张函数式编程，纯组件，数据不可变，单项数据流，手动触发双向
    编写语法
      vue webpack+vue-loader单文件组件，html、css、js分离
      react jsx + all in js
    构建工具
      vue vue-cli 可选择，渐进式
      react 单一，不能自定义
    数据绑定
      vue 双向绑定 mvvm 数据劫持、发布订阅模式
      react 单向数据流 setState，异步，多个setState 加入异步队列，一起执行，第二个参数可以拿到更新后的
    diff算法
      vue 1、内存中构建虚拟dom树，2、渲染称真实dom树，3、改变生成新的虚拟dom树，4、平层比较diff，5、把对比差异重新渲染。选择更新的的渲染，不是全部渲染
      react 1、dom改变---直接卸载重新create，2、dom一样，不会卸载，但是update内容，3、所有同层级的字节点，都可以通过key区分。 逐个对节点进行更新，转换目标节点，最后插入新的节点
    指令
      vue v-for v-if v-model  @click
      react 没有指令
    性能优化
      vue 不需要手动优化，依赖追踪，精确知道是否需要重绘。但是数据特别多的时候 watcher 就多，就页面卡顿。所以数据比较多的大型项目倾向react。
      react shouldComponentUpdate React.PureComponent（浅比较）ew_state.todos = new_state.todos.slice() immutable
    原生渲染native
      vue Weex（一套代码，抹平各个平台差异，简化开发） uni-app
      react react native（可写多套代码，同一个语言框架。承认差异，对平台进行抽象，方法论的角度解决多平台）
    srr服务端渲染
      vue Nuxt.js
      react Next.js
    生命周期
      vue 8个：beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destoryed
      react getDefaultProps getInitialState componentWillMount render componentDidMount componentWillReceiveProps(nextProps,nextState) shouldComponentUpdate(nextProps,nextState) componentWillUpdate render componentDidUpdate componentWillUnmount
    销毁组件
      vue 对残留的dom结构进行处理必须在destroyed生命周期函数中处理。
      react componentWillUnmount之后全部消除
    状态集管理工具
      vue vuex（store、state、getters、actions、dispatch、mutations、commit）
      react redux （store、reducer、getState、action、dispatch、subscribe）
    总结
      轻量级的视图层
8、gulp grunt webpack
    grunt 构建工具，自动化 Gruntfile.js 最老牌的，一切皆配置，配置项太多
    gulp 构建工具，基于任务流的自动化构建工具 简单 异常处理比较麻烦 不太适合自定义模块开发和spa开发
    webpack 模块打包器，模块化管理工具和打包工具 loader 适合模块和spa开发 学习成本高
    rollup 模块打包器，es6，类库专用，减少死代码缩小包体积，对代码拆分、静态资源、commonjs模块支持不好
    parcel 是快速、零配置的 web 应用程序打包器，其打包速度也要比Webpack快，只能用来构建用于运行在浏览器中的网页
9、工程化和模块化
    webpack rollup 组件化 自动化 规范化
10、浏览器渲染过程，回流，重绘
    CRP critical/ rendering / path 关键渲染路径
    1、url解析
    2、缓存检查
        强缓存 Expires/Cache-Control，后着优先级高
        协商缓存 Last-Modified/Etag if-Modified-Since/if-None-Match 304
        数据缓存 localStorage vuex redux
    3、DNS解析 2～120ms
    4、TCP三次握手
    5、发送请求，分析url，设置请求报文（头，主体）
    6、服务器返回请求的文件
    7、TCP四次挥手
    8、页面渲染
        html parser ---》 dom tree
        css parser ---》 style tree
        attachment ---》 render tree
        layout
        GPU painting
    重绘：不影响布局的改变，只需要UI层的重新绘制，损耗少
    回流：尺寸，结构等改变，页面重新渲染。
        页面初次渲染
        浏览器窗口大小改变
        元素尺寸，位置，内容发生改变
        字体大小改变
        添加删除dom
        激活 css 伪类
        BOM 查询，调用。。。
11、水平垂直居中
    一、行内元素居中布局
      水平居中
        行内元素可设置：text-align: center;
        flex布局设置父元素：display: flex; justify-content: center;
      垂直居中
        单行文本父元素确认高度：height === line-height
        多行文本父元素确认高度：display: table-cell; vertical-align: middle;
    二、块级元素居中布局
        水平居中
          定宽: margin: 0 auto;
          不定宽： 参考上诉例子中不定宽高例子。
        垂直居中
          position: absolute设置left、top、margin-left、margin-top(定高)；
          position: fixed设置margin: auto(定高)；
          display: table-cell；
          transform: translate(x, y)；
          flex(不定高，不定宽)；
          grid(不定高，不定宽)，兼容性相对比较差；

12、为什么叫做align-items？怎么改变flex轴的方向
    flex中，有两种轴   一种是主轴，一种是交叉轴
    主轴  会根据 你所设置flex-direction不同而不同
    justify-content  代表的是横轴   而align-items  所代表的是纵轴
13、BFC，能解决哪些问题？
    块级格式化上下文 独立渲染区域，bfc内部和外部隔离
14、事件循环机制，为什么要分微任务和宏任务？为什么微任务先执行？
    宏任务先执行然后再执行微任务。因为script是一个大的宏任务！
    在js中任务分为同步任务和异步任务，为什么这么搞？因为js是单线程的，为什么是单线程的？因为js设计之初是为了解决页面交互的，一种脚本没必要那么复杂，其次如果js设计成多线程的，会有很大的问题，多线程要考虑线程之间的资源抢占，死锁，冲突之类的，加入你在操作一个dom节点把它改成了红色，然后另一个线程把它删除掉了，这时你就会完全懵掉。
15、call，apply，bind
    call: fn.call(target, 1, 2)
    apply: fn.apply(target, [1, 2])
    bind: fn.bind(target)(1,2)
16、Set、Map说一下，Map和Object 区别？
    Set集合是一种无重复元素的列表，检测给定的值在某个集合中是否存在
      constructor、size、add、has、delete、clear
    Map集合内含多组键值对，Map结构提供了“值—值”的对应
      set get has、delete、clear、
17、promise.all
18、回文字符串
19、原型、原型链
    实例.__proto__ === 原型
    原型.constructor === 构造函数
    构造函数.prototype === 原型
    实例.constructor === 构造函数
    __proto__ 将对象连接起来组成了原型链，是一个实现继承，和共享属性的有限的对象链
    属性查找机制 Object.prototype
    属性修改机制
20、作用域，作用域链
    该上下文中声明的变量和声明的作用范围。块级作用域，函数作用域
    理解为 一组对象列表，包含父级 和自身的变量对象。自上而下的形成一条 链式作用域
21、语义化的理解
    利于SEO与浏览器的解析时间
22、将 “20210426141823” 转换为 “2021年04月26日 14:18:23”
23、箭头函数、关于 this 你了解多少（4种）

### ok面试题

1、原型、原型链
    Function和Object的关系
      这是JavaScript比较奇葩的一个地方，也是不太让人容易接受的一点。
      我们知道一般任何对象都是Object的instance，因为原型链的顶端都指向Object.prototype。那么Object本身是什么？Object也是个函数，而任何函数都是Function的实例对象，比如Array，String，当然Object也包括在内，它也是Function的实例，即：
        Object.__proto__ === Function.prototype;
        Object instanceof Function === true
      同时，Function是个对象，它的原型是Function.__proto__，指向Function.prototype，并且这个原型链向上继续指向Object.prototype，即：
        Function.__proto__.__proto__ === Object.prototype;
        Function instanceof Object === true
      这样就有了一个JavaScript里经常说到的蛋鸡问题：
        Object instanceof Function === true
        Function instanceof Object === true
2、作用域，作用域链
```JS
var foo = {n:1};
(function(foo){
  var foo;
  console.log(foo.n);
  foo.n=3;
  foo={n:2};
  console.log(foo.n);
})(foo);
console.log(foo.n);
```
3、promis
4、await、async
5、http1.0 http1.1 http2.0
6、常见状态码
7、缓存
8、node
9、nextTick
10、v-if、v-show
11、数据响应式
12、diff 算法
13、key的作用
14、webpack Plugin
15、性能优化

## tt

### 准备

1、偏H5，移动端

2、产品优化升级，产品思维，业务能力

3、性能优化

4、项目可维护性

5、RN
