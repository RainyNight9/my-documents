# 复盘

## sx

面试题：

### 1、水平垂直居中

    1、定宽高
      一、绝对定位 + 负margin值
      二、绝对定位 + transform
      三、绝对定位 + left/right/bottom/top + margin
      四、flex布局
      五、grid布局 + margin: auto;
      六、table-cell + vertical-align + inline-block/margin: auto
    2、不定宽高
      一、绝对定位 + transform
      二、table-cell + vertical-align + inline-block
      三、flex布局
      四、flex变异布局 + margin: auto;
      五、grid + flex布局（align-self: center;justify-self: center;）
      六、gird + margin布局（margin: auto;）
      七、writing-mode属性布局

一、内联元素居中布局

  水平居中

    行内元素可设置：text-align: center;
    flex布局设置父元素：display: flex; justify-content: center;

  垂直居中

    单行文本父元素确认高度：height === line-height
    多行文本父元素确认高度：display: table-cell; vertical-align: middle;

二、块级元素居中布局

    水平居中
      定宽: margin: 0 auto;
      不定宽： 参考上诉例子中不定宽高例子。

    垂直居中
      position: absolute设置left、top、margin-left、margin-top(定高)；
      position: fixed设置margin: auto(定高)；
      display: table-cell；
      transform: translate(x, y)；
      flex(不定高，不定宽)；
      grid(不定高，不定宽)，兼容性相对比较差；

[答案](https://juejin.cn/post/6844903982960214029)

### 2、css动画，css动画和js动画区别

    transition: 过渡动画
      transition-property: 属性
      transition-duration: 间隔
      transition-timing-function: 曲线
      transition-delay: 延迟
      常用钩子: transitionend

    animation / keyframes
      animation-name: 动画名称，对应@keyframes
      animation-duration: 间隔
      animation-timing-function: 曲线
      animation-delay: 延迟
      animation-iteration-count: 次数
        infinite: 循环动画
      animation-direction: 方向
        alternate: 反向播放
      animation-fill-mode: 静止模式
        forwards: 停止时，保留最后一帧
        backwards: 停止时，回到第一帧
        both: 同时运用 forwards / backwards
      常用钩子: animationend

    动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现
      translate
      scale
      rotate
      skew
      opacity
      color

### 3、position定位区别
  
  static(默认)
  relative(自身)
  absolute(相对的元素是它最近的一个祖先，该祖先满足：position的值必须是：relative、absolute、fixed，若没有这样的祖先则相对于body进行定位)
  fixed（浏览器视窗，不随滚动）
  sticky

### 4、继承

    一、原型链继承 prototype
      无法实现多继承（一个子类继承成多个父类）
      创建子类实例的时候，无法向父类构造函数传参
      有子类实例共享父类引用属性的问题（因为子类的原型指向的是父类的一个实例，假如父类的私有属性有一个是数组(引用类型)，那么任一子类都可以操作这个数组，从而导致其他子类使用的这个数组也会发生变化）
    二、借用父类构造函数继承 call或者apply
      解决了原型链继承的缺点
      每次创建子类实例时，都要调用一次父类构造函数，影响性能
      只继承父类的实例属性(私有属性)，没有继承父类的原型属性
    三、组合式继承(原型链继承 + 借用构造函数继承)
      解决了上两种的缺点
    四、ES6的class/extends继承
      使用extends关键字继承父类的原型属性，调用super来继承父类的实例属性，且保留向父类构造函数传参的优点

### 5、闭包及场景

    闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

    作用: 读取函数内部的函数,始终保持在内存中
    优点: 变量长期保持在内存中,不会清除,避免全局污染
    缺点: 增大内存使用,导致内存泄漏
    场景：自执行函数。返回一个函数（防抖、节流、）。在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。作为函数参数传递的形式。

### 6、缓存

    缓存策略: 可分为 强缓存 和 协商缓存

      * Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires

        Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）

        Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）
        Cache-Control 的值：no-cache、no-store、max-age、max-stale、min-fresh、no-transform、only-if-cached、must-revalidate、public、private、proxy-revalidate......

      * 当缓存已经过期时，使用协商缓存

        唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
        最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)

          如果一致，则直接返回 304 通知浏览器使用缓存
          如不一致，则服务端返回新的资源

      * Last-Modified 缺点：

        周期性修改，但内容未变时，会导致缓存失效
        最小粒度只到 s， s 以内的改动无法检测到

      * Etag 的优先级高于 Last-Modified

### 7、数据类型

    boolean null undefined number string symbol BigInt

    引用数据类型（Object）：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象。

    1、基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；

    2、引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。

### 8、类型判断 typeof instanceof Object.prototype.toString

    1、instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；

    2、而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。

    typeof null        // 'object'
    typeof console.log // 'function'

    let str = 'Covid-19'
    str instanceof String   // false

```js
function myInstanceof(left, right) {
  // 这里先用typeof来判断基础数据类型，如果是，直接返回false
  if(typeof left !== 'object' || left === null) return false;
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  let proto = Object.getPrototypeOf(left);
  while(true) {                  //循环往下寻找，直到找到相同的原型对象
    if(proto === null) return false;
    if(proto === right.prototype) return true;//找到相同原型对象，返回true
    proto = Object.getPrototypeof(proto);
  }
}
// 验证一下自己实现的myInstanceof是否OK
console.log(myInstanceof(new Number(123), Number));    // true
console.log(myInstanceof(123, Number));                // false   
```

### 9、事件循环

    事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

      微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
      宏任务 macrotask(task): setTimout / script / IO / UI Rendering

### 10、vue vs react 生命周期 数据响应 setState（事务）使用场景区别对比

    * setState：事务 (Transaction):

      是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；

    * setState: React 中用于修改状态，更新视图。它具有以下特点:

      异步与同步: setState并不是单纯的异步或同步，这其实与调用时的环境相关:

        在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是"异步"的；

          原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；

            在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；
            在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；

          问题: 无法在setState后马上从this.state上获取更新后的值。
          
          解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；

        在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值；

          原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；

      批量更新: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；

      函数式: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；

        使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；

      注意事项:

        setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；
        当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法:

          将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；
          在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；

### 11、原型

    * 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。

    * 构造函数: 可以通过new来 新建一个对象 的函数。

    * 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。

```js
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的
// instance.hasOwnProperty('constructor') === false 
实例.constructor === 构造函数
```

### 12、跨域

* JSONP: 利用`<script>`标签不受跨域限制的特点，缺点是只能支持 get 请求

```js
function jsonp(url, jsonpCallback, success) {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
```

* 设置 CORS: Access-Control-Allow-Origin：*
* postMessage
* nginx
    location /apis {
        rewrite  ^.+apis/?(.*)$ /$1 break;
        include  uwsgi_params;
        proxy_pass   http://localhost:1894;
    }
* webpack 本地代理

### 13、内存泄漏

    意外的全局变量: 无法被回收
    定时器: 未被正确关闭，导致所引用的外部变量无法被释放
    事件监听: 没有正确销毁 (低版本浏览器可能出现)
    闭包: 会导致父级中的变量无法被释放
    dom 引用: dom 元素被删除时，内存中的引用未被正确清空

**可用 chrome 中的 timeline（Performance） 进行内存标记，可视化查看内存的变化情况，找出异常点。**

### 14、性能优化

    1. 编码优化

        * 数据读取:

          通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；
          对象嵌套越深，读取值也越慢；
          
          最佳实践:
            尽量在局部作用域中进行 变量缓存；
            避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护；

        * 循环: 循环通常是编码性能的关键点；

          代码的性能问题会再循环中被指数倍放大；
          
          最佳实践:
            尽可能 减少循环次数；
              减少遍历的数据量；
              完成目的后马上结束循环；
            避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
            js 中使用 倒序循环 会略微提升性能；
            尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；

        * 条件流程性能: Map / Object > switch > if-else

        * 减少 cookie 体积: 能有效减少每次请求的体积和响应时间；

          去除不必要的 cookie；
          压缩 cookie 大小；
          设置 domain 与 过期时间

        * dom 优化:

          减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
          减少重绘与回流:

            多次操作合并为一次；
            减少对计算属性的访问；

              例如 offsetTop， getComputedStyle 等
              因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；

            大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
            使用DocumentFragment / cloneNode / replaceChild进行操作；

          使用事件委托，避免大量的事件绑定；

        * css 优化:

          层级扁平，避免过于多层级的选择器嵌套；
          特定的选择器 好过一层一层查找:  .xxx-child-text{} 优于 .xxx .child .text{}
          减少使用通配符与属性选择器；
          减少不必要的多余属性；
          使用 动画属性 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
          使用 <link> 替代原生 @import；

        * html 优化:

          减少 dom 数量，避免不必要的节点或嵌套；
          避免<img src="" />空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

            IE 向页面所在的目录发送请求；
            Safari、Chrome、Firefox 向页面本身发送请求；
            Opera 不执行任何操作。

          图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；
          语义化标签 有利于 SEO 与浏览器的解析时间；
          减少使用 table 进行布局，避免使用<br />与<hr />；

    2. 页面基础优化

      * 引入位置: css 文件<head>中引入， js 文件<body>底部引入；

        影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；

      * 减少请求 (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
      * 减少文件体积:

        删除多余代码:
          tree-shaking
          UglifyJs
          code-spliting

        混淆 / 压缩代码，开启 gzip 压缩；
        多份编译文件按条件引入:
          针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
          可以利用<script type="module"> / <script type="module">进行条件引入用

        动态 polyfill，只针对不支持的浏览器引入 polyfill；

      * 图片优化:

        根据业务场景，与UI探讨选择 合适质量，合适尺寸；
        根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
        小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；
        合适场景下，使用 iconfont 或者 svg；

      * 使用缓存:

        浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；
        CDN缓存: 静态文件合理使用 CDN 缓存技术；

          HTML 放于自己的服务器上；
          打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
          由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；

        服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
        数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

    3. 首屏渲染优化

      * css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；
      * 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；
      * 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；
      * 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑；

        控制字体包的加载时机；
        如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；

      * 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存；
      * 分清轻重缓急:

        重要的元素优先渲染；
        视窗内的元素优先渲染；

      * 服务端渲染(SSR):

        减少首屏需要的数据量，剔除冗余数据和请求；
        控制好缓存，对数据/页面进行合理的缓存；
        页面的请求使用流的形式进行传递；

      * 优化用户感知:

        利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
        尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
        动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
        js 执行时间避免超过 100ms，超过的话就需要做:

          寻找可 缓存 的点；
          任务的 分割异步 或 web worker 执行；

    4、性能优化，谷歌调试工具

        Performance
        lighthouse

### 15、html5、css3

HTML5 的一些最有趣的新特性：

    新的语义元素，比如 <header>, <footer>, <article>, and <section>。
    新的表单控件，比如数字、日期、时间、日历和滑块。
    强大的图像支持（借由 <canvas> 和 <svg>）
    强大的多媒体支持（借由 <video> 和 <audio>）
    强大的新 API，比如用本地存储取代 cookie。

## blm

### 1、B/S架构工作原理

    第一层表现层：主要完成用户和后台的交互及最终查询结果的输出功能。
    第二层逻辑层：主要是利用服务器完成客户端的应用逻辑功能。
    第三层数据层：主要是接受客户端请求后独立进行各种运算。

    B/S架构采取浏览器请求，服务器响应的工作模式。

### 2、flex与margin区别

### 3、float与position区别

    absolute/fixed和float对比
    类似：元素都会从文档流删除，但是依旧会影响布局;都会生成一个块级框，无论原来是不是块级元素。
    区别：float的包含块是最近的块级祖先元素。

    visibility:hidden和display:none的区别：
    visibility:hidden设置元素不可见，但是元素依旧会影响布局，只是元素部分呈现为空白;
    display:none元素不显示并且从文档流中删除，对文档布局没有任何影响。

### 4、transform有哪些属性，使用场景

    transform的属性值主要包括旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix

      1、transform:rotate(30deg),2D旋转，正值为顺时针旋转，负值为逆时针旋转，默认旋转基点是中心点，也可以通过transform-origin（X,Y）改变基点。
      2、transform:skew(30deg,10deg),注意，这里的X轴和Y轴与我们平时认为的坐标系的XY轴正好相反；且X轴正值是逆时针变形，而Y轴正值是顺时针变形。基点默认为中心点。另外还有skewX、skewY，分别用来设置单一方向上的扭曲。可以通过transform-origin（X,Y）改变基点
      3、transform：scale（2,1.5），表示在水平方向（X轴）缩放2倍，在垂直方向（Y轴）缩放1.5倍。基本默认为中心点。这里的X、Y轴指的是像坐标系一样的X、Y轴，与transform:skew（X,Y）的X
      Y轴不同。 另外同样有scaleX(<number>)、scaleY(<number>)用来分别设置单一方向上的缩放。可以通过transform-origin（X,Y）改变基点。
      4、transform：translate（100px，20px），表示在水平方向上移动100px；在垂直方向上移动20px，比较好理解，另外也同样有translateX、translateY值分别设置单一方向上的位移，可以通过transform-origin（X,Y）改变基点

### 5、html语义化

    根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

    为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
    用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
    有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
    方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
    便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

### 7、webpack的作用

    * 预编译
    * 模块打包工具, 提供了 打包功能 和一套 文件处理机制,高度的可拓展性
    * 模块机制
    * 文件编译

### 8、loader原理

    * 不同格式文件转换器
    * 对 Webpack 传入的字符串进行按需修改
    * 需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串
    * 链式传递，按照配置时相反的顺序链式执行；
    * 基于 Node 环境，拥有 较高权限，比如文件的增删查改；
    * 可同步也可异步；
    * 单一原则: 每个 Loader 只做一件事；
    * 链式调用: Webpack 会按顺序链式调用每个 Loader；
    * 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；

### blm 面试题

### 1、flex 原理

    * 弹性布局
    * 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
    * 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）
    * flex-direction属性决定主轴的方向
    * flex-wrap 如果一条轴线排不下，如何换行
    * flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
    * justify-content属性定义了项目在主轴上的对齐方式。
    * align-items属性定义项目在交叉轴上如何对齐。
    * align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

    * order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
    * flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
    * flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
    * flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
    * flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
    * align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

### 2、移动端适配原理

```js
(function (doc, win) {
  var docEl = doc.documentElement,
    resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    recalc = function () {
      var clientWidth = docEl.clientWidth;
      if (clientWidth >= 750) {
        clientWidth = 750;
      };
      if (clientWidth <= 320) {
        clientWidth = 320;
      }
      if (!clientWidth) return;
      docEl.style.fontSize = 100 * (clientWidth / 750) + 'px';
    };
  if (!doc.addEventListener) return;
  win.addEventListener(resizeEvt, recalc, false);
  doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);
```

### 3、this

    * this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。
    * this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
    * 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。
    * 这个记录会包含函数在哪里被调用（调用栈），函数的调用方式、传入的参数等信息。
    * this就是这个记录的一个属性，会在函数执行的过程中用到。
    * this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

判断一个运行中函数的this绑定，就需要找到函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断this的绑定对象：

    1、由new调用？绑定到新创建的对象。
    2、由call或者apply（或者bind）调用？绑定到指定的对象。
    3、由上下文对象调用？绑定到那个上下文对象。
    4、默认：严格模式下绑定到undefined，否则绑定到全局对象。

自己总结（可能有偏差）：

    1、事件调用环境：谁触发事件，函数里边的this 指向的就是谁
    
    2、普通函数里边的this 最终指向的是调用它的对象
    
    3、函数被多层对象所包含，如果函数被最外层对象调用，this指向的也只是它上一级的对象
    
    4、构造函数中的this指向的是实例化对象，注意return
    
    5、箭头函数本身是没有this 和 arguments

this有四种情况

    1、当在函数调用的时候指向widow
    
    2、当方法调用的时候指向调用对象
    
    3、当用apply和call上下文调用的时候指向传入的第一个参数 
    
    4、构造函数调用指向实例对象 

JS中this关键字， 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。全局函数调用时，this指向全局函数； 应该是指向调用全局函数的对象。

### 4、防抖节流，也手写

    就是指触发事件后在n秒内函数只能执行一次，如果n秒内又触发了事件，则会重新计算函数执行时间。
    
    就是指连续触发事件但是在一段时间中只执行一次函数，控制函数被触发的频率。

## ok

### 1、DOM

    Document Object Model
    document

### 2、BOM

    Browser Object Model
    浏览器对象模型 window

### 3、AJAX

    Asynchronous Javascript And XML
    let xhr = new XMLHttpRequest()
    xhr.onreadystatechange = ()=>{
      if(xhr.readyState == 4) {
        if(xhr.status == 200 || xhr.status == 0) {
            document.write(xhr.responseText); // 将返回结果以字符串形式输出
        }
      }
    }
    xhr.open(method,URL,flag,name,password)
    xhr.send(data);

### 4、gulp grunt webpack

    grunt 构建工具，自动化 Gruntfile.js 最老牌的，一切皆配置，配置项太多
    gulp 构建工具，基于任务流的自动化构建工具 简单 异常处理比较麻烦 不太适合自定义模块开发和spa开发
    webpack 模块打包器，模块化管理工具和打包工具 loader 适合模块和spa开发 学习成本高
    rollup 模块打包器，es6，类库专用，减少死代码缩小包体积，对代码拆分、静态资源、commonjs模块支持不好
    parcel 是快速、零配置的 web 应用程序打包器，其打包速度也要比Webpack快，只能用来构建用于运行在浏览器中的网页

### 5、浏览器渲染过程，回流，重绘

    CRP critical/ rendering / path 关键渲染路径
    1、url解析
    2、缓存检查
        强缓存 Expires/Cache-Control，后着优先级高
        协商缓存 Last-Modified/Etag if-Modified-Since/if-None-Match 304
        数据缓存 localStorage vuex redux
    3、DNS解析 2～120ms
    4、TCP三次握手
    5、发送请求，分析url，设置请求报文（头，主体）
    6、服务器返回请求的文件
    7、TCP四次挥手
    8、页面渲染
        html parser ---》 dom tree
        css parser ---》 style tree
        attachment ---》 render tree
        layout
        GPU painting
    重绘：不影响布局的改变，只需要UI层的重新绘制，损耗少
    回流：尺寸，结构等改变，页面重新渲染。
        页面初次渲染
        浏览器窗口大小改变
        元素尺寸，位置，内容发生改变
        字体大小改变
        添加删除dom
        激活 css 伪类
        BOM 查询，调用。。。

### 6、为什么叫做align-items？怎么改变flex轴的方向

    flex中，有两种轴   一种是主轴，一种是交叉轴
    主轴  会根据 你所设置flex-direction不同而不同
    justify-content  代表的是横轴   而align-items  所代表的是纵轴

### 7、BFC，能解决哪些问题？

    块级格式化上下文 独立渲染区域，bfc内部和外部隔离

### 8、事件循环机制，为什么要分微任务和宏任务？为什么微任务先执行？

    宏任务先执行然后再执行微任务。因为script是一个大的宏任务！
    在js中任务分为同步任务和异步任务，为什么这么搞？因为js是单线程的，为什么是单线程的？因为js设计之初是为了解决页面交互的，一种脚本没必要那么复杂，其次如果js设计成多线程的，会有很大的问题，多线程要考虑线程之间的资源抢占，死锁，冲突之类的，加入你在操作一个dom节点把它改成了红色，然后另一个线程把它删除掉了，这时你就会完全懵掉。

### 9、call，apply，bind

    call: fn.call(target, 1, 2)
    apply: fn.apply(target, [1, 2])
    bind: fn.bind(target)(1,2)

### 10、Set、Map说一下，Map和Object 区别？

    Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构
    Set集合是一种无重复元素的列表，检测给定的值在某个集合中是否存在
      constructor、size、add、has、delete、clear
    Map集合内含多组键值对，Map结构提供了“值—值”的对应
      set get has、delete、clear、

### 11、原型、原型链

    实例.__proto__ === 原型
    原型.constructor === 构造函数
    构造函数.prototype === 原型
    实例.constructor === 构造函数
    __proto__ 将对象连接起来组成了原型链，是一个实现继承，和共享属性的有限的对象链
    属性查找机制 Object.prototype
    属性修改机制

### 12、作用域，作用域链

    该上下文中声明的变量和声明的作用范围。块级作用域，函数作用域
    理解为 一组对象列表，包含父级 和自身的变量对象。自上而下的形成一条 链式作用域

### 13、语义化的理解

    利于SEO与浏览器的解析时间

### 14、将 “20210426141823” 转换为 “2021年04月26日 14:18:23”

### ok面试题

### 1、原型、原型链

    Function和Object的关系
      这是JavaScript比较奇葩的一个地方，也是不太让人容易接受的一点。
      我们知道一般任何对象都是Object的instance，因为原型链的顶端都指向Object.prototype。那么Object本身是什么？Object也是个函数，而任何函数都是Function的实例对象，比如Array，String，当然Object也包括在内，它也是Function的实例，即：
        Object.__proto__ === Function.prototype;
        Object instanceof Function === true
      同时，Function是个对象，它的原型是Function.__proto__，指向Function.prototype，并且这个原型链向上继续指向Object.prototype，即：
        Function.__proto__.__proto__ === Object.prototype;
        Function instanceof Object === true
      这样就有了一个JavaScript里经常说到的蛋鸡问题：
        Object instanceof Function === true
        Function instanceof Object === true

### 2、作用域，作用域链

```JS
var foo = {n:1};
(function(foo){
  var foo;
  console.log(foo.n);
  foo.n=3;
  foo={n:2};
  console.log(foo.n);
})(foo);
console.log(foo.n);
```

3、promis
4、await、async
5、http1.0 http1.1 http2.0
6、常见状态码
7、缓存
8、node
9、nextTick
10、v-if、v-show
11、数据响应式
12、diff 算法
13、key的作用
14、webpack Plugin
15、性能优化

## tt

### 8、实现1---100的相加的方法

```js
// 1
var total = 0;
for (var i = 1; i <= 100; i++) {
  total += i;
}
// 2
var total = new Array(100).fill().map((item, index) => index + 1).reduce((total, cur) => total + cur, 0)
// 3
function num(n) {
  if (n == 1) return 1;
  return num(n - 1) + n;
}
var total = num(100);

// 为了使效果更准确，这里取1到1万的累加，取多组数据的平均值；
// 方法1：平均耗时：0.426106770833ms
// 方法2：平均耗时：0.820068359375ms
// 方法3：平均耗时：0.465087890625ms

// 1、数组reduce的效率最慢，主要原因在于遍历了两遍数组。当[1,2,…,10000]数组已知时，效率会提高10倍以上。
// 2、普通for循环与递归速度差不多，但是递归有最大调用次数限制
```

### 9、const str = '4+10*2-(16-8)' 书写函数实现并返回计算结果

    eval('4+10*2-(16-8)')
    (new Function('return ' + '4+10*2-(16-8)'))()

```js
var a,b,c;
(function(){
  eval('var b = 2');
  (1, eval)('var c = 3');   // 逗号操作符，括号表达式，返回的是最后一个挂载在window上的eval
  (new Function('var a = 4'))();
  console.log('<br>a: ' + a);  //undefined
  console.log('<br>b: ' + b);  //2
  console.log('<br>c: ' + c);  //3
})()
console.log('<br>a: ' + a);  //undefined
console.log('<br>b: ' + b);  //undefined
console.log('<br>c: ' + c);  //3
```

### 10、cdn提升静态资源加载速度原理

    内容分发网络（Content delivery network或Content distribution network，缩写：CDN）。简单来说它主要的工作是把我们需要被分发的内容分发到世界各地的各个节点上，让世界各地的人都可以在距离最近的网络节点拿到想要拿到的内容，减少网络传输距离从而达到加速的目的（需要提过资源绝对地址告诉cdn厂商，让厂商去智能拉取）。

### 12、http协议

    1 HTTP1.0和HTTP1.1的区别
      1.1 长连接(Persistent Connection)
            HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。
      1.2 节约带宽
            HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。
      1.3 HOST域
            在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。
      1.4 缓存处理
            在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
      1.5 错误通知的管理
            在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

    2 HTTP1.1和HTTP2.0的区别
      2.1 多路复用
            HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
      2.2 头部数据压缩
            在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。
            HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
      2.3 服务器推送
            服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。
            为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

### 13、tcp协议

    TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
    虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为
    对数据准确性要求高，速度可以相对较慢的，可以选用TCP
    对比：
      UDP 无连接 不可靠传输，不使用流量控制和拥塞控制 支持一对一，一对多，多对一和多对多交互通信 面向报文 首部开销小，仅8字节 适用于实时应用（IP电话、视频会议、直播等）
      TCP 面向连接 可靠传输，使用流量控制和拥塞控制 只能是一对一通信 面向字节流 首部最小20字节，最大60字节 适用于要求可靠传输的应用，例如文件传输

### 19、box-sizing 盒模型

    content-box (W3C 标准盒模型) 宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。
    border-box (IE 盒模型) 从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度
    padding-box (FireFox 曾经支持)
    margin-box (浏览器未实现)

### 20、BFC

    块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
    阻止margin重叠
    可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)
    自适应两栏布局
    可以阻止元素被浮动元素覆盖

### 21、移动端适配

    <meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;">
    1、rem适配
    2、vw，vh布局
    3、px为主，vx和vxxx（vw/vh/vmax/vmin）为辅，搭配一些flex（推荐）

    // 1px粗的问题解决 transform: scale(0.5) 方案
    div {
        height:1px;
        background:#000;
        -webkit-transform: scaleY(0.5);
        -webkit-transform-origin:0 0;
        overflow: hidden;
    }

### 22、rem相关

    rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素
    这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应

### 24、z-index

    层叠上下文
    在同一层叠上下文中，层叠等级才有意义
    z-index的优先级最高
    background/border --》z-index为负值 --》块级元素 ---》浮动元素 ---》行内元素---》z-index：0/auto ---》z-index为正值

### 25、实现一个宽高比为4:3的div

    padding-top的值为：height / width * 100%

### 26、%比的padding是基于width 还是 height

### 30、typescript的config type和interface

    都可以描述一个对象或者函数
    都允许拓展（extends）
    type 可以声明基本类型别名，联合类型，元组等类型
    type 语句中还可以使用 typeof 获取实例的 类型进行赋值
    interface 能够声明合并
    能用 interface 实现，就用 interface , 如果不能就用 type

### 32、快排思路 找出第k大的数 [1,3,5,2,2] 5, 3

### 33、qiankun核心

    JS沙箱、CSS样式隔离、应用HTML入口接入、应用通信、应用路由

### 35、压缩的代码怎么找到问题在哪里

    uglifyjs
    SourceMap

### 43、单词全排列 lol --》 lol，llo，oll

### 44、5，3，7，2，0，4，1，2 ---》 5 2，3 4，7 0

### 45、location

1、自我介绍
2、感受最深的，经历最深刻的
3、浏览器的渲染流程
4、缓存
5、原型链
6、继承
7、this 指向问题
8、类型判断
9、算法：比较两个版本号
10、性能优化

## 图森

Vue把一个列表从底部移动到顶部，是如何做虚拟dom更新的

### 对typescript了解有多少

    Typescript是强类型的Javascript超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。

    type和interface

    都可以描述一个对象或者函数
    都允许拓展（extends）
    type 可以声明基本类型别名，联合类型，元组等类型
    type 语句中还可以使用 typeof 获取实例的 类型进行赋值
    interface 能够声明合并
    能用 interface 实现，就用 interface , 如果不能就用 type

### 项目

1、背景

    内部需要
    AST 虚拟DOM 抽象语法树 vue模版字符串表达式
    始于xf，做于sq和hwl

2、实现功能

    常见form列表组件封装UI统一， tag 自动匹配， key 自动双向绑定
        placeholder
        allowClear
    支持 新建表单、编辑表单、详情展示（DetailData）
    新增自定义 InputNumberSelect RangeTimePicker InputSelect。。。
    支持栅格布局，可配置
    支持联动 hidden boolean/表达式
    支持自定义 otherNode（多节点） Slot（无规则节点）
        a-space隔开一行多个
        this.$scopedSlots?.default()
    支持可配置携带按钮，图标，提示，单位。。。

```js
// 判断是否是“函数”
// JSON无法使用函数值的参数，所以使用"{{...}}"来标记为函数
isExpression(func) {
  if (typeof func !== "string") return false;
  // 这样的 pattern {{.....}}
  const pattern = /^{{(.+)}}$/;
  const reg1 = /^{{(function.+)}}$/;
  const reg2 = /^{{(.+=>.+)}}$/;
  if (
    typeof func === "string" &&
    func.match(pattern) &&
    !func.match(reg1) &&
    !func.match(reg2)
  ) {
    return true;
  }
  return false;
},
// 获取可运行的表达式
getRunString(func) {
  const pattern = /^{{(.+)}}$/;
  return func.match(pattern);
},
// 解析函数字符串值
// formData 整个 form 的值
evaluateString(string, formData) {
  return Function(`"use strict";
  const formData = ${JSON.stringify(formData)};
  return (${string})`)();
},
```

```js
mounted() {
  window.addEventListener("resize", this.handleResize);
  const clientW = document.documentElement.clientWidth;
  this.handleClientW(clientW);
},
beforeDestroy() {
  window.removeEventListener("resize", this.handleResize);
},
handleResize(e) {
  const e_width = e.target.innerWidth;
  this.handleClientW(e_width);
},
handleClientW(width) {
  const len = this.getListLength();
  if (width >= 1600) {
    this.advancedFalseNum = 3;
    this.offsetFlag = 4 - (len % 4) - 1;
  } else if (width >= 992) {
    this.advancedFalseNum = 2;
    this.offsetFlag = 3 - (len % 3) - 1;
  } else if (width >= 576) {
    this.advancedFalseNum = 1;
    this.offsetFlag = 0;
  } else {
    this.advancedFalseNum = len + 1;
    this.offsetFlag = 0;
  }
},

const offset = this.advanced ? this.offsetFlag : 0;
<a-col
  xxl={{ span: 6, offset: 6 * offset }}
  lg={{ span: 8, offset: 8 * offset }}
  sm={{ span: 12, offset: 0 }}
  xs={{ span: 24, offset: 0 }}
  class="btns-box"
>
```

3、成果

    团队技术分享，时间效率提高

### 脚手架

1、commander 负责读取命令
2、inquirer负责问询
3、download 下载
4、rimraf 删除.git文件夹

### 项目模版

2、内置布局组件（头部，菜单，内容区域）
3、内置了菜单路由配置管理
4、内置了搭建新页面的流程
5、内置了主题定制配置管理
6、内置了服务端接口交互配置
7、内置了权限管理配置（菜单权限、操作权限...）
8、内置了对接管理中心T系列登录流程

### 5、怎么管理团队

    Leader 的视野和高度
      团队 Leader 除了前端视角外，应多了解后端、客户端、产品、运营等多方面知识面扩展自己的思维，并多与横向团队的 Leader 学习交流。让自己多些工程师的行业视野与全局视角。
    为下边的员工考虑
      看在团队实现阶段目标后给大家争取多少福利。加多少工资，跳槽后能拿多少钱，是否实现自身价值。简单粗暴点的标准是看是否有公司从你这抢人作为判断依据，让你的团队变得牛逼。
    公司/部门影响力
      业界影响力，公司内部影响力
    团队脾气，性格（脾性、心态、经验、甚至人品昔昔相关）
      团队内不合群，负能量，过分个性...多交流沟通，需要自己以身作则践行团队文化。
    执行力
      团队驱动力

### 7、vue vs react

    设计思想
      vue 渐进式框架 双向绑定
      react 主张函数式编程，纯组件，数据不可变，单项数据流，手动触发双向
    编写语法
      vue webpack+vue-loader单文件组件，html、css、js分离
      react jsx + all in js
    构建工具
      vue vue-cli 可选择，渐进式
      react 单一，不能自定义
    数据绑定
      vue 双向绑定 mvvm 数据劫持、发布订阅模式
      react 单向数据流 setState，异步，多个setState 加入异步队列，一起执行，第二个参数可以拿到更新后的
    diff算法
      vue 1、内存中构建虚拟dom树，2、渲染称真实dom树，3、改变生成新的虚拟dom树，4、平层比较diff，5、把对比差异重新渲染。选择更新的的渲染，不是全部渲染
      react 1、dom改变---直接卸载重新create，2、dom一样，不会卸载，但是update内容，3、所有同层级的字节点，都可以通过key区分。 逐个对节点进行更新，转换目标节点，最后插入新的节点
    指令
      vue v-for v-if v-model  @click
      react 没有指令
    性能优化
      vue 不需要手动优化，依赖追踪，精确知道是否需要重绘。但是数据特别多的时候 watcher 就多，就页面卡顿。所以数据比较多的大型项目倾向react。
      react shouldComponentUpdate React.PureComponent（浅比较）ew_state.todos = new_state.todos.slice() immutable
    原生渲染native
      vue Weex（一套代码，抹平各个平台差异，简化开发） uni-app
      react react native（可写多套代码，同一个语言框架。承认差异，对平台进行抽象，方法论的角度解决多平台）
    srr服务端渲染
      vue Nuxt.js
      react Next.js
    生命周期
      vue 8个：beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destoryed
      react getDefaultProps getInitialState componentWillMount render componentDidMount componentWillReceiveProps(nextProps,nextState) shouldComponentUpdate(nextProps,nextState) componentWillUpdate render componentDidUpdate componentWillUnmount
    销毁组件
      vue 对残留的dom结构进行处理必须在destroyed生命周期函数中处理。
      react componentWillUnmount之后全部消除
    状态集管理工具
      vue vuex（store、state、getters、actions、dispatch、mutations、commit）
      react redux （store、reducer、getState、action、dispatch、subscribe）
    总结
      轻量级的视图层

1、this 箭头函数的this
2、http 调用 https 接口
3、小程序 rpx
4、jsonp 的缺点
5、flex 的属性
6、let const var
8、栅格布局原理
9、虚拟dom 的事件和 真实dom 的事件，那个先执行
10、react setData
11、vue
12、http https
13、缓存

1、数据平台、数据可视化
2、数据质量系统
3、react vue
4、webpack
5、node

1、系统架构
2、技术选型
3、数据结构与算法
4、react vue
5、网络协议、webserver
6、地图经验、可视化经验

JavaScript
一、基础
1、JavaScript语言数据类型(基础类型和引用类型)有哪些？
2、说一下对闭包、作用域、上下文的理解
3、prototype和__proto__的区别
4、列举继承的几种方式
二、事件流
1、说一下事件流过程和性能优化
2、事件DOM0和DOM2的区别
3、event对象常见的使用方法
4、如何创建自定义事件
三、浏览器
1、说一下Event Loop过程
2、从url打开到页面展示的过程
3、说一下页面重绘和回流和注意事项
4、浏览器存储的几种方式和优缺点
5、Web worker作用是什么
6、Web Components优势有哪些
7、V8回收机制是什么
8、什么情况会内存溢出和解决办法
四、常用技巧
1、列举出script标签引入方式
2、列举出对象拷贝的方法和优缺点
3、列举出判断数据类型方法和优缺点
4、new、instanceof、bind、apply、call实现方式
5、去抖和节流实现方式
6、Promise实现方式
五、HTTP
1、什么是TCP的三次握手
2、常见状态码
3、几种请求方式的作用
4、跨域的几种方式
5、介绍一下XSS和CSRF
6、http和https的区别
7、介绍一下CDN加速
8、说一下XHR的readystate几个状态
9、怎样加快页面响应速度
六、ES6
1、分别介绍一下CommonJS规范，AMD规范，CMD规范和ES6 Import
2、let、const和var区别
3、箭头函数this指向
4、promise有几种状态
5、什么是回调地狱，解决方式是什么
七、Vue
1、vue的生命周期有哪些
2、vue数据劫持的实现方式
3、nextTick的实现方式和作用
4、Proxy与defineProperty的区别
5、v-html存在的问题
6、如何给自定组件做v-model
7、组件之间如何通信
8、组件的key的作用是什么
八、React
1、jsx的本质是很么
2、shouldComponentUpdate用什么作用
3、说一下Redux单向数据流
4、redux如何触发组件更新
5、setState是同步还是异步
6、什么是函数组件
7、介绍一下hooks几个常见钩子函数
8、hooks的优势是什么
9、如何组件加载时调用异步请求(hooks)
10、使用hooks遇到的问题
九、算法
1、实现数据快速排序
2、实现斐波那契数列实现
3、多维数组转一维数组
4、求数组内两数之和为目标值，不可重复
5、在100000数中找到最大的数
6、求阶乘
