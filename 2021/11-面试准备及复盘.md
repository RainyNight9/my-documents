# 复盘

## sx

面试题：

1、水平垂直居中

    1、定宽高
      一、绝对定位 + 负margin值
      二、绝对定位 + transform
      三、绝对定位 + left/right/bottom/top + margin
      四、flex布局
      五、grid布局 + margin: auto;
      六、table-cell + vertical-align + inline-block/margin: auto
    2、不定宽高
      一、绝对定位 + transform
      二、table-cell + vertical-align + inline-block
      三、flex布局
      四、flex变异布局 + margin: auto;
      五、grid + flex布局（align-self: center;justify-self: center;）
      六、gird + margin布局（margin: auto;）
      七、writing-mode属性布局

一、内联元素居中布局

  水平居中

    行内元素可设置：text-align: center;
    flex布局设置父元素：display: flex; justify-content: center;

  垂直居中

    单行文本父元素确认高度：height === line-height
    多行文本父元素确认高度：display: table-cell; vertical-align: middle;

二、块级元素居中布局

    水平居中
      定宽: margin: 0 auto;
      不定宽： 参考上诉例子中不定宽高例子。

    垂直居中
      position: absolute设置left、top、margin-left、margin-to(定高)；
      position: fixed设置margin: auto(定高)；
      display: table-cell；
      transform: translate(x, y)；
      flex(不定高，不定宽)；
      grid(不定高，不定宽)，兼容性相对比较差；

[答案](https://juejin.cn/post/6844903982960214029)

2、动画，css动画和js动画区别

    transition: 过渡动画
      transition-property: 属性
      transition-duration: 间隔
      transition-timing-function: 曲线
      transition-delay: 延迟
      常用钩子: transitionend

    animation / keyframes
      animation-name: 动画名称，对应@keyframes
      animation-duration: 间隔
      animation-timing-function: 曲线
      animation-delay: 延迟
      animation-iteration-count: 次数
        infinite: 循环动画
      animation-direction: 方向
        alternate: 反向播放
      animation-fill-mode: 静止模式
        forwards: 停止时，保留最后一帧
        backwards: 停止时，回到第一帧
        both: 同时运用 forwards / backwards
      常用钩子: animationend

    动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现
      translate
      scale
      rotate
      skew
      opacity
      color

3、定位 static(默认) relative(自身) absolute(窗口，随滚动，上边不是static的) fixed（浏览器视窗，不随滚动） sticky
4、继承 
    
    一、原型链继承 prototype 
      无法实现多继承（一个子类继承成多个父类）
      创建子类实例的时候，无法向父类构造函数传参
      有子类实例共享父类引用属性的问题（因为子类的原型指向的是父类的一个实例，假如父类的私有属性有一个是数组(引用类型)，那么任一子类都可以操作这个数组，从而导致其他子类使用的这个数组也会发生变化）
    二、借用父类构造函数继承 call或者apply
      解决了原型链继承的缺点
      每次创建子类实例时，都要调用一次父类构造函数，影响性能
      只继承父类的实例属性(私有属性)，没有继承父类的原型属性
    三、组合式继承(原型链继承 + 借用构造函数继承)
      解决了上两种的缺点
    四、ES6的class/extends继承
      使用extends关键字继承父类的原型属性，调用super来继承父类的实例属性，且保留向父类构造函数传参的优点

5、闭包及场景

    闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

    作用:读取函数内部的函数,始终保持在内存中
    优点:变量长期保持在内存中,不会清除,避免全局污染
    缺点:增大内存使用,导致内存泄漏
    场景：自执行函数。返回一个函数（防抖、节流、）。在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。作为函数参数传递的形式。

6、缓存

    缓存策略: 可分为 强缓存 和 协商缓存

      * Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires

        Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）

        Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）
        Cache-Control 的值：no-cache、no-store、max-age、max-stale、min-fresh、no-transform、only-if-cached、must-revalidate、public、private、proxy-revalidate......

      * 当缓存已经过期时，使用协商缓存

        唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
        最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)

          如果一致，则直接返回 304 通知浏览器使用缓存
          如不一致，则服务端返回新的资源

      * Last-Modified 缺点：

        周期性修改，但内容未变时，会导致缓存失效
        最小粒度只到 s， s 以内的改动无法检测到

      * Etag 的优先级高于 Last-Modified

7、数据类型

    boolean null undefined number string symbol BigInt

    引用数据类型（Object）：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象。

    1、基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；

    2、引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。

8、typeof instanceof Object.prototype.toString

    1、instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；

    2、而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。

    typeof null        // 'object'
    typeof console.log // 'function'

    let str = 'Covid-19'
    str instanceof String   // false

```js
function myInstanceof(left, right) {
  // 这里先用typeof来判断基础数据类型，如果是，直接返回false
  if(typeof left !== 'object' || left === null) return false;
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  let proto = Object.getPrototypeOf(left);
  while(true) {                  //循环往下寻找，直到找到相同的原型对象
    if(proto === null) return false;
    if(proto === right.prototype) return true;//找到相同原型对象，返回true
    proto = Object.getPrototypeof(proto);
  }
}
// 验证一下自己实现的myInstanceof是否OK
console.log(myInstanceof(new Number(123), Number));    // true
console.log(myInstanceof(123, Number));                // false   
```

9、事件循环

    事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

      微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
      宏任务 macrotask(task): setTimout / script / IO / UI Rendering

10、vue vs react 生命周期 数据响应 setState（事务）使用场景区别对比

    * setState：事务 (Transaction):

      是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作；

    * setState: React 中用于修改状态，更新视图。它具有以下特点:

      异步与同步: setState并不是单纯的异步或同步，这其实与调用时的环境相关:

        在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是"异步"的；

          原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；

            在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；
            在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；

          问题: 无法在setState后马上从this.state上获取更新后的值。
          
          解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；

        在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值；

          原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；

      批量更新: 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；

      函数式: 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；

        使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用；

      注意事项:

        setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；
        当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法:

          将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；
          在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；

11、原型

    * 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。

    * 构造函数: 可以通过new来 新建一个对象 的函数。

    * 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。

```js
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的
// instance.hasOwnProperty('constructor') === false 
实例.constructor === 构造函数
```

12、跨域

* JSONP: 利用<script>标签不受跨域限制的特点，缺点是只能支持 get 请求

```js
function jsonp(url, jsonpCallback, success) {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
```
* 设置 CORS: Access-Control-Allow-Origin：*
* postMessage
* nginx
* webpack 本地代理

13、内存泄漏

    意外的全局变量: 无法被回收
    定时器: 未被正确关闭，导致所引用的外部变量无法被释放
    事件监听: 没有正确销毁 (低版本浏览器可能出现)
    闭包: 会导致父级中的变量无法被释放
    dom 引用: dom 元素被删除时，内存中的引用未被正确清空

**可用 chrome 中的 timeline（Performance） 进行内存标记，可视化查看内存的变化情况，找出异常点。**

14、性能优化

    1. 编码优化

        * 数据读取:

          通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；
          对象嵌套越深，读取值也越慢；
          
          最佳实践:
            尽量在局部作用域中进行 变量缓存；
            避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护；

        * 循环: 循环通常是编码性能的关键点；

          代码的性能问题会再循环中被指数倍放大；
          
          最佳实践:
            尽可能 减少循环次数；
              减少遍历的数据量；
              完成目的后马上结束循环；
            避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
            js 中使用 倒序循环 会略微提升性能；
            尽量避免使用 for-in 循环，因为它会枚举原型对象，耗时大于普通循环；

        * 条件流程性能: Map / Object > switch > if-else

        * 减少 cookie 体积: 能有效减少每次请求的体积和响应时间；

          去除不必要的 cookie；
          压缩 cookie 大小；
          设置 domain 与 过期时间

        * dom 优化:

          减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；
          减少重绘与回流:

            多次操作合并为一次；
            减少对计算属性的访问；

              例如 offsetTop， getComputedStyle 等
              因为浏览器需要获取最新准确的值，因此必须立即进行重排，这样会破坏了浏览器的队列整合，尽量将值进行缓存使用；

            大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复；
            使用DocumentFragment / cloneNode / replaceChild进行操作；

          使用事件委托，避免大量的事件绑定；

        * css 优化:

          层级扁平，避免过于多层级的选择器嵌套；
          特定的选择器 好过一层一层查找:  .xxx-child-text{} 优于 .xxx .child .text{}
          减少使用通配符与属性选择器；
          减少不必要的多余属性；
          使用 动画属性 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；
          使用 <link> 替代原生 @import；

        * html 优化:

          减少 dom 数量，避免不必要的节点或嵌套；
          避免<img src="" />空标签，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求

            IE 向页面所在的目录发送请求；
            Safari、Chrome、Firefox 向页面本身发送请求；
            Opera 不执行任何操作。

          图片提前 指定宽高 或者 脱离文档流，能有效减少因图片加载导致的页面回流；
          语义化标签 有利于 SEO 与浏览器的解析时间；
          减少使用 table 进行布局，避免使用<br />与<hr />；

    2. 页面基础优化

      * 引入位置: css 文件<head>中引入， js 文件<body>底部引入；

        影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；

      * 减少请求 (http 1.0 - 1.1)，合并请求，正确设置 http 缓存；
      * 减少文件体积:

        删除多余代码:
          tree-shaking
          UglifyJs
          code-spliting

        混淆 / 压缩代码，开启 gzip 压缩；
        多份编译文件按条件引入:
          针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；
          可以利用<script type="module"> / <script type="module">进行条件引入用

        动态 polyfill，只针对不支持的浏览器引入 polyfill；

      * 图片优化:

        根据业务场景，与UI探讨选择 合适质量，合适尺寸；
        根据需求和平台，选择 合适格式，例如非透明时可用 jpg；非苹果端，使用 webp；
        小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；
        合适场景下，使用 iconfont 或者 svg；

      * 使用缓存:

        浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；
        CDN缓存: 静态文件合理使用 CDN 缓存技术；

          HTML 放于自己的服务器上；
          打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；
          由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；

        服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；
        数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

    3. 首屏渲染优化

      * css / js 分割，使首屏依赖的文件体积最小，内联首屏关键 css / js；
      * 非关键性的文件尽可能的 异步加载和懒加载，避免阻塞首页渲染；
      * 使用dns-prefetch / preconnect / prefetch / preload等浏览器提供的资源提示，加快文件传输；
      * 谨慎控制好 Web字体，一个大字体包足够让你功亏一篑；

        控制字体包的加载时机；
        如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积；

      * 合理利用 Localstorage / server-worker 等存储方式进行 数据与资源缓存；
      * 分清轻重缓急:

        重要的元素优先渲染；
        视窗内的元素优先渲染；

      * 服务端渲染(SSR):

        减少首屏需要的数据量，剔除冗余数据和请求；
        控制好缓存，对数据/页面进行合理的缓存；
        页面的请求使用流的形式进行传递；

      * 优化用户感知:

        利用一些动画 过渡效果，能有效减少用户对卡顿的感知；
        尽可能利用 骨架屏(Placeholder) / Loading 等减少用户对白屏的感知；
        动画帧数尽量保证在 30帧 以上，低帧数、卡顿的动画宁愿不要；
        js 执行时间避免超过 100ms，超过的话就需要做:

          寻找可 缓存 的点；
          任务的 分割异步 或 web worker 执行；

15、html5、css3

## blm

1、性能优化，谷歌调试工具

    Performance
    lighthouse

2、react、vue

3、node、reatful api

4、es6+ promise

5、脚手架
6、B/S架构工作原理

    第一层表现层：主要完成用户和后台的交互及最终查询结果的输出功能。
    第二层逻辑层：主要是利用服务器完成客户端的应用逻辑功能。
    第三层数据层：主要是接受客户端请求后独立进行各种运算。

    B/S架构采取浏览器请求，服务器响应的工作模式。

7、居中布局
8、flex与margin区别
9、float与position区别

    absolute/fixed和float对比
    类似：元素都会从文档流删除，但是依旧会影响布局;都会生成一个块级框，无论原来是不是块级元素。
    区别：float的包含块是最近的块级祖先元素。

    visibility:hidden和display:none的区别：
    visibility:hidden设置元素不可见，但是元素依旧会影响布局，只是元素部分呈现为空白;
    display:none元素不显示并且从文档流中删除，对文档布局没有任何影响。

10、transform有哪些属性，使用场景

    transform的属性值主要包括旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix

      1、transform:rotate(30deg),2D旋转，正值为顺时针旋转，负值为逆时针旋转，默认旋转基点是中心点，也可以通过transform-origin（X,Y）改变基点。
      2、transform:skew(30deg,10deg),注意，这里的X轴和Y轴与我们平时认为的坐标系的XY轴正好相反；且X轴正值是逆时针变形，而Y轴正值是顺时针变形。基点默认为中心点。另外还有skewX、skewY，分别用来设置单一方向上的扭曲。可以通过transform-origin（X,Y）改变基点
      3、transform：scale（2,1.5），表示在水平方向（X轴）缩放2倍，在垂直方向（Y轴）缩放1.5倍。基本默认为中心点。这里的X、Y轴指的是像坐标系一样的X、Y轴，与transform:skew（X,Y）的X
      Y轴不同。 另外同样有scaleX(<number>)、scaleY(<number>)用来分别设置单一方向上的缩放。可以通过transform-origin（X,Y）改变基点。
      4、transform：translate（100px，20px），表示在水平方向上移动100px；在垂直方向上移动20px，比较好理解，另外也同样有translateX、translateY值分别设置单一方向上的位移，可以通过transform-origin（X,Y）改变基点

11、继承
12、vue数据绑定、key的作用、虚拟dom、diff算法
13、怎么管理团队

    Leader 的视野和高度
      团队 Leader 除了前端视角外，应多了解后端、客户端、产品、运营等多方面知识面扩展自己的思维，并多与横向团队的 Leader 学习交流。让自己多些工程师的行业视野与全局视角。
    为下边的员工考虑
      看在团队实现阶段目标后给大家争取多少福利。加多少工资，跳槽后能拿多少钱，是否实现自身价值。简单粗暴点的标准是看是否有公司从你这抢人作为判断依据，让你的团队变得牛逼。
    公司/部门影响力
      业界影响力，公司内部影响力
    团队脾气，性格（脾性、心态、经验、甚至人品昔昔相关）
      团队内不合群，负能量，过分个性...多交流沟通，需要自己以身作则践行团队文化。
    执行力
      团队驱动力

14、html语义化

    根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。

    为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；
    用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
    有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
    方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
    便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
  
15、数据类型
16、类型判断
17、this指向
18、set、map

  Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构

19、parmise.all 使用场景


20、vue生命周期，主要挂载和请求时机
21、watch和computed
22、nextTick
23、vuex 为什么不是响应式的

    原来获取 vuex 中的值一定要用计算属性获取
    
24、webpack的作用
25、loader原理
26、vue.$set vue.$delete

## tt

### 准备

1、偏H5，移动端

2、产品优化升级，产品思维，业务能力

3、性能优化

4、项目可维护性

5、RN


