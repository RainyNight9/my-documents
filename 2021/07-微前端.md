# 微前端

微前端解决特定问题：技术栈无关

https://micro-frontends.org/

https://martinfowler.com/articles/micro-frontends.html

https://qiankun.umijs.org/zh

![A diagram showing 3 applications independently going from source control, through build, test and deployment to production](https://martinfowler.com/articles/micro-frontends/deployment.png)

![img](https://pic1.zhimg.com/v2-2efaa89ac52b38913bdcc0f3603c8e58_1440w.jpg?source=172ae18b)

## 一.为什么需要微前端

通过3W(what,why,how)的方式来讲解微前端

## What?什么是微前端?

微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。

微前端的核心在于拆, 拆完后再合!

## Why?为什么去使用它?

* 不同团队间开发同一个应用，技术栈不同怎么破？
* 希望每个团队都可以独立开发，独立部署怎么破？
* 项目中还需要老的应用代码怎么破？
  
我们是不是可以将一个应用划分成若干个子应用，将子应用打包成一个个的lib。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！从而解决了前端协同开发问题。

好处：

* 增量升级（Incremental upgrades）
* 简单、解耦的代码库（Simple, decoupled codebases）
* 独立部署（Independent deployment）
* 自治团队（Autonomous teams）

## How?怎样落地微前端?

* 服务端模板组合
* 构建时集成（将每个微前端作为一个包发布）
* 通过 iframe 进行运行时集成（Why Not Iframe）
* 通过 JavaScript 进行运行时集成(每个微前端都使用`<script>`标签包含在页面上，并在加载时公开一个全局函数作为其入口点。然后容器应用程序确定应该挂载哪个微前端，并调用相关函数来告诉微前端何时何地渲染自己。)
* 通过 Web Components 的运行时集成

## iframe？

体验不好，有点像之前后端模板 vs spa  

微前端 你可以理解为，iframe 的 spa版

单页路由监听 =》 不同的（spa是组件）app

## 手写一部分微前端原理

1. 加载应用 （html-loader）
   1. 通过html，解析出页面加载的css，js，和容器html
2. css污染
   1. 每个子应用用不同的css前缀,BEM(Block Element Modifier) 约定项目前缀
   2. Dynamic Stylesheet动态样式表，当应用切换时移除老应用样式，添加新应用样式
   3. Shadow DOM真正意义上的隔离
   4. css in js
   5. scroped css
   6. CSS-Modules打包时生成不冲突的选择器名

3. js沙箱
   1. Eval(function(){js content})内部执行加载的js  完成了封装
   2. window.xx = 123
      1. proxy window Proxy 代理沙箱,不影响全局环境
   3. window 快照
      1. 每次应用加载前，记录一下，应用卸载的时候，恢复一下。快照沙箱，在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)
4. 路由切换
   1. 拦截一下addEventListener， 拦截一下hashchage，popstate（history）记录

### 子应用生命周期

### 通信方案

* 基于URL来进行数据传递，但是传递消息能力弱
* 基于CustomEvent实现通信
* 基于props主子应用间通信
* 使用全局变量、Redux进行通信

### 公共依赖

* CDN - externals
* webpack联邦模块

## qiankun的实战

>总结：子应用可以独立构建，运行时动态加载,主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount方法）

qiankun 做沙箱隔离主要分为三种：

      legacySandBox (基于 Proxy API 来实现的) (仅用于 singular 单实例模式)
      proxySandBox (基于 Proxy API 来实现的) (多实例模式会使用 proxySandBox)
      snapshotSandBox。

### legacySandBox

legacySandBox 的核心思想是什么呢？legacySandBox 的本质上还是操作 window 对象，但是他会存在三个状态池，分别用于子应用卸载时还原主应用的状态和子应用加载时还原子应用的状态：

* addedPropsMapInSandbox： 存储在子应用运行时期间新增的全局变量，用于卸载子应用时还原主应用全局变量；
* modifiedPropsOriginalValueMapInSandbox：存储在子应用运行期间更新的全局变量，用于卸载子应用时还原主应用全局变量；
* currentUpdatedPropsValueMap：存储子应用全局变量的更新，用于运行时切换后还原子应用的状态；

所以，总结起来，legacySandBox 还是会操作 window 对象，但是他通过激活沙箱时还原子应用的状态，卸载时还原主应用的状态来实现沙箱隔离的。

### proxySandBox

在 qiankun 中，proxySandBox 用于多实例场景。什么是多实例场景，这里我简单提下，一般我们的中后台系统同一时间只会加载一个子应用的运行时。但是也存在这样的场景，某一个子应用聚合了多个业务域，这样的子应用往往会经历多个团队的多个同学共同维护自己的业务模块，这时候便可以采用多实例的模式聚合子模块（这种模式也可以叫微前端模块）。

和 legacySandBox 最直接的不同点就是，为了支持多实例的场景，proxySandBox 不会直接操作 window 对象。并且为了避免子应用操作或者修改主应用上诸如 window、document、location 这些重要的属性，会遍历这些属性到子应用 window 副本（fakeWindow）上.

因为 proxySandBox 不直接操作 window，所以在激活和卸载的时候也不需要操作状态池更新 / 还原主子应用的状态了。相比较看来，proxySandBox 是现阶段 qiankun 中最完备的沙箱模式，完全隔离了主子应用的状态，不会像 legacySandBox 模式下在运行时期间仍然会污染 window。

### snapshotSandBox

在不支持 Proxy 的场景下会降级为 snapshotSandBox，如同他的名字一样，snapshotSandBox 的原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。

总结起来，对当前的 window 和记录的快照做 diff 来实现沙箱。

