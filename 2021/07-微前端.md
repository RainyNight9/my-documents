# 微前端训练营

微前端解决特定问题：技术栈无关

https://micro-frontends.org/

https://martinfowler.com/articles/micro-frontends.html

https://qiankun.umijs.org/zh

![A diagram showing 3 applications independently going from source control, through build, test and deployment to production](https://martinfowler.com/articles/micro-frontends/deployment.png)

![img](https://pic1.zhimg.com/v2-2efaa89ac52b38913bdcc0f3603c8e58_1440w.jpg?source=172ae18b)

## 一.为什么需要微前端

通过3W(what,why,how)的方式来讲解微前端

## What?什么是微前端?

微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。

微前端的核心在于拆, 拆完后再合!

## Why?为什么去使用它?

* 不同团队间开发同一个应用，技术栈不同怎么破？
* 希望每个团队都可以独立开发，独立部署怎么破？
* 项目中还需要老的应用代码怎么破？
  
我们是不是可以将一个应用划分成若干个子应用，将子应用打包成一个个的lib。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！从而解决了前端协同开发问题。

## How?怎样落地微前端?

## iframe？

体验不好，有点像之前后端模板 vs spa  

微前端 你可以理解为，iframe 的 spa版

单页路由监听 =》 不同的（spa是组件）app

## 手写一部分微前端原理

1. 加载应用 （html-loader）
   1. 通过html，解析出页面加载的css，js，和容器html
2. css污染
   1. 每个子应用用不同的css前缀,BEM(Block Element Modifier) 约定项目前缀
   2. Dynamic Stylesheet动态样式表，当应用切换时移除老应用样式，添加新应用样式
   3. Shadow DOM真正意义上的隔离
   4. css in js
   5. scroped css
   6. CSS-Modules打包时生成不冲突的选择器名

3. js沙箱
   1. Eval(function(){js content})内部执行加载的js  完成了封装
   2. window.xx = 123
      1. proxy window Proxy 代理沙箱,不影响全局环境
   3. window 快照
      1. 每次应用加载前，记录一下，应用卸载的时候，恢复一下。快照沙箱，在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)
4. 路由切换
   1. 拦截一下addEventListener， 拦截一下hashchage，popstate（history）记录

### 子应用生命周期

### 通信方案

* 基于URL来进行数据传递，但是传递消息能力弱
* 基于CustomEvent实现通信
* 基于props主子应用间通信
* 使用全局变量、Redux进行通信

### 公共依赖

* CDN - externals
* webpack联邦模块

## qiankun的实战

>总结：子应用可以独立构建，运行时动态加载,主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount方法）
